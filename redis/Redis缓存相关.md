## Redis作为缓存相关的问题



缓存是现在被广泛使用的一种提高系统性能的手段。

相对来说数据库的承受能力较弱，如果请求全部打到数据库，那么数据库很快就会成为性能瓶颈。

查询数据库之前，先查询速度较快的缓存，可以有效减少对数据库的请求，以此达到提高系统吞吐量，性能的目的。

但是缓存如果使用不当也就会出现缓存一致性的问题。



#### 缓存一致性

缓存一致性主要是缓存和数据库的一致性问题，不仅仅是存在`Redis`。

如果缓存一致性出现问题，可能会导致数据的错误，比如数据库已经修改的内容，从缓存中获取却是旧的，这就不一致了。

为了一致性和容错，往往使用`redis`作为缓存时，会对key添加一个过期时间，

这里说的一致性好像是最终一致性，并不是强一致性。

##### 解决办法

###### 1.延时双删

具体的操作步骤如下：

1. 删除缓存
2. 更新数据库
3. 延迟一定的时间后，再删除缓存

第一次删除缓存是直接删除的旧数据，第二次删除则是保障，如果更新期间请求进来依旧会缓存旧数据，为了防止这种情况，再确保更新成功后再次删除缓存。

该方法可能会造成缓存击穿的情况。

###### 2. 异步更新缓存

更新缓存和更新数据库作异步处理。

比如对于`MySQL`而言，比较常见的可以使用canal + 消息队列做异步。

canal负责解析MySQL的binlog，并将解析结果推送到消息队列(kafka,rabbitMQ等)，而后由系统接受并更新缓存。



好像上面的两种情况都会存在一段时间的不一致性，所以考虑过用2pc等方式做强一致性，但如果因为缓存更新失败的原因导致业务失败，好像也有点扯。





#### 缓存穿透

请求中带有在数据库中都查不到的key，缓存中不存在则每次直接打到数据库进行查询。

当流量增大时可能会打爆数据库，也可能会有人特地拿不存在的来查询。

##### 解决方法

1. **布隆过滤器**

   布隆过滤器可以用来判断数据库是否存在某个key，不存在则直接返回。

   但存在一定的误报率，且增加了之后可能会影响正常查询。

2. 缓存空值

   即数据库查询到空时，也保留缓存，为了容错考虑可以设置稍短一点的过期时间。





#### 缓存击穿https://github.com/liukelin/canal_mysql_nosql_sync

热点key失效之后，同一时间有大量请求进来，所以就全部打到了数据库上。

缓存雪崩的情况会使数据库一下子压力陡增，严重的甚至会打爆。

##### 解决办法

1. 分布式锁

   上锁之后，同一个时间只有一个请求能查库，之后的请求走缓存。

   但要注意锁的范围和粒度。

2. 永远不过期

   可以直接直接去除热点key的过期时间。https://github.com/liukelin/canal_mysql_nosql_sync



#### 缓存雪崩缓存雪崩的情况

同一时间大量的key同时失效，导致请求直接到数据库。

#### 解决办法

1. 设置不同的失效时间

   往往相同的失效时间是导致雪崩的主要原因，再极端一点可以像击穿一样缓存永远不失效。

2. 定时刷新

   部分热点key可以设置定时的刷新，保证缓存的时间充异步更新缓存足。

3. 缓存预热

   是在服务上线或者缓存重启时候的必要，避免缓存为空，导致刚开始的请求全部到数据库。







