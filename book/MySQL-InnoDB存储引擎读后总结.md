## MySQL

![MySQL体系结构](https://github.com/CheNbXxx/StrugglingInJava/blob/master/img/MySQL体系结构.jpg)

- 从中可以看出`MySQL`的整体结构包括以下部分：
  1. 连接池组件(Connection Pool)，包括认证和缓存等小组件。
  2. 管理组服务以及工具(Management Services & Utillities),其中包括备份，复制，管理，集群等。
  3. SQL接口(SQL Interface)，进行DML、DDL，存储过程，视图等的操作，是用户通过SQL操作的起点。
  4. 解析器(Parser)
  5. 查询优化(Optimizer)
  6. 缓存、缓冲(Caches & Buffers)
  7. 插件式存储引擎(Pluggable Storage Engines)，实现对内存、索引、存储的组织管理。
     - 存储引擎是相对于表来说的,每个表都可以指定不同引擎,因此被称为`插件式`.
  8. 物理文件，从中也可以看出`MySQL`的文件包括了**数据和日志**两类，日志包括`Redo Log`，`Undo Log`，数据包括`Data page`和`Index page`.



---

##  InnoDB存储引擎                                  

- 自5.5版本开始,`InnoDB`就一直是`MySQL`的默认存储引擎.

- `InnoDB`的特性:
  - 支持事务
  - 支持表锁和行锁
  - 支持外键<font size="2">(这个好像没什么用,我的日常开发都是以程序实现外键关联)</font>
  - 支持`MVCC`<font size="2">(书中并未提及详细)</font>
  - 提供一致性非锁定读
  - 插入缓冲/读写缓冲
  - 二次写
  - ...

### InnoDB的体系结构

![InnoDB存储引擎体系结构](https://github.com/CheNbXxx/StrugglingInJava/blob/master/img/InnoDB体系结构.jpeg)

- 简单来说`InnoDB`由**内存池及其文件结构**组成.

#### 内存池

- 内存池中包括**运行的线程组**和**缓冲池**部分.
- `InnoDB`中对数据的操作都是通过缓冲池实现的，更新时的具体对象也是缓冲池中的数据页，查询时也实现查询的缓冲池，没有时也是先从磁盘读取。

##### 后台线程

- 内存池中运行着很多不同种类的后台线程,承担着维护所有相关的数据结构,重做日志缓冲等职责.

###### Master Thread

- 后台线程中最为核心的线程.
- 线程中通过thread sleep<font size="2">(表示间隔时间并不准确,唤醒之后也不一定立即获得CPU执行时间)</font>实现1每秒和每10秒两种循环,完成以下操作:
  1. 刷新日志缓冲和脏页回磁盘
  2. 合并插入缓冲
  3. 回收无用的Undo页<font size="2">(10s)</font>

###### IO Thread

- 该类线程的主要作用就是**负责`InnoDB`中大量的AIO(异步IO)的请求回调处理.**

###### Purge Thread

- `InnoDB1.1`版本引入,可以使用`Purge Thread`分担一部分`Master Thread`中对Undo页面的回收工作.

###### Page Cleaner Thread

-  `InnoDB1.2`版本引入,负责刷新脏页回磁盘,减轻`Master Thread`的工作<font size="2">(我去...当爹一样供着)</font>.

![InnoDB的内存数据对象.png](https://github.com/CheNbXxx/StrugglingInJava/blob/master/img/InnoDB的内存数据对象.png)

##### 缓冲池

- `InnoDB`是**基于磁盘存储的,以页为单位维护**,并不像`Redis`直接基于内存,所以也就很有必要使用缓冲池尽量消除CPU和磁盘的读写速度差距.

- 简单来说`InnoDB`获取数据的过程都会先检查缓冲池中是否存在该数据对应的数据页,不存在就从磁盘中读取并放入缓冲池.
- 从上图中,我们可以看到`InnoDB`的缓冲池中存放着的的数据有**索引页,数据页,Undo页,插入缓冲,自适应哈希索引,锁信息等.**
- `InnoDB`缓冲池的内存区域是使用`LRU算法`管理的,`InnoDB`缓冲池中的默认页大小为16KB,将内存划分为`LRU  List`,`Free List`进行具体的管理.

###### Free List

- 空闲页列表,数据库刚启动时,`LRU List`是空的,此时划分的页都保存在`Free List`,需要分页时会优先从`Free List`查找.

###### LRU List

- 就是通过`LRU`算法实际管理使用中的页的列表结构.
- `InnoDB`对`LRU`做了一些优化:**新插入的页并非是直接放入列表首部,而是放在`midpoint`位置,该位置之前为`new`部分,之后为`old`部分.** 这么做的目的是为了避免大批量的读操作直接清空列表中真实的热点部分(new部分).
- `InnoDB`同时支持页的压缩操作,16kb -> 8kb,4kb等,保存在`LRU List`的`unzip_LRU`部分,
- `Flush List`也是`LRU List`的一部分,用于保存脏页,数据库会自行通过`CheckPoint`机制将其刷新回磁盘.
  - 脏页即为修改过的数据页.

##### 重做日志缓冲(redo log buffer)

- 重做日志并非一开始就写入文件中,而是先在缓冲区,然后后台线程会以一定的频率刷新到文件中.
- 重做日志缓冲刷新回文件的三种情况:
  1. `Master Thread`会以每秒的循环
  2. 在事务提交的时候,也就是所谓的`Force-log-at-commit`机制.
  3. 当重做日志缓冲池剩余空间小于1/2时

##### 额外的内存池

- `InnoDB`使用内存堆的形式来管理内存,所以需要这么一块额外的内存区域供别的对象申请.



##### Checkpoint技术

- 事务型数据库为了保证持久性要求,一般都采用`Write Ahead Log策略`,即事务提交时**先写重做日志,再写页**,而两者为了读写效率都存放在内存中,为了减少内存的大小需求,以及数据库宕机后恢复的速度(重做日志太大会导致宕机之后需要很长时间去恢复),此时就需要`CheckPoint`技术.在规定的触发时机将缓冲池的脏页落盘，然后清除`checkpoint`之前的redo log。
- 需要注意,`MySQL5.6`版本之后,脏页的刷新工作可以通过单独的`Page Cleaner Thread`完成,故再也不需要阻塞用户的查询线程.
- `Checkpoint`可以分为以下两类:
  1. Sharp Checkpoint
  2. Fuzzy Checkpoint

###### Sharp Checkpoint

- 发生在数据库关闭的时候将所有的脏页刷新回磁盘.

###### Fuzzy Checkpoint

- 在数据库运行时动态的刷新一部分脏页回磁盘.
- 具体情形可分为以下几种:
  1. Master Thread Checkppoint
     - `Master Thread`两种间隔的循环中都会刷新一定比例的脏页回磁盘.
  2. FLUSH_LRU_LIST Checkpoint
     - 是为了保证`LRU List`中有足够的空闲页可以用,若过少则会从末尾移除,若移除的时脏页此时就需强制刷新.也算是`LRU List`的溢出.
  3. Async/Sync Flush Checkpoint
     - 为了保证重做日志的循环可用性,若过多的脏页堆积在`LRU List`,和与其对应的重做日志同时保留在文件中,会使重做日志过满而不可用.
  4. Dirty Page too much Checkpoint
     - 看名字就知道时脏页太多了.



#### InnoDB的文件组

##### MySQL通用文件

- 包含参数文件,日志文件,socket文件,pid文件以及表结构文件等等.

###### 日志文件

- 如同`Java`中的日志一样,`MySQL`的日志文件也记录了数据库运行的日常信息,是锁定错误以及错误之后复原的关键文件.
  1. 错误日志:记录`MySQL`启动,运行,关闭的过程.
  2. 慢查询日志: 记录运行时间超过一定阈值的SQL语句,可通过查看该日志确认是否有SQL语句需要优化
  3. 查询日志: 记录了所有对数据库的请求信息,无论请求是否得到正确的执行.
  4. 二进制文件: 记录所有可能对数据库造成修改的操作.

##### InnoDB存储引擎文件

- 是`InnoDB`专有的文件内容,**包括表空间文件和重做日志文件.**

###### 表空间文件(tablespace file)

- `使用ibdata1文件保存所有基于InnoDB存储引擎的表的数据和索引,初始大小为10mb,是共享表空间文件,具体的文件名可使用innodb_data_file_path指定.InnoDB`存储引擎使用表空间(tablespace)来存储数据,保存索引和记录,在方式上存在**共享和独立两种**:

  - **共享表空间结构**

    使用**`ibdata1`文件**保存所有基于`InnoDB`存储引擎的表的数据和索引.

  - **独立表空间结构**

    以**`表名.idb`文件**的形式,保存每张表的数据和索引等信息.**注意:就算是此时也有一部分数据是保存在共享表空间内的**,例如系统事务文件,插入缓冲索引页. 

- 可以看出,无论如何一张表的索引和数据大部分情况下还是在同一个文件内的.

- `表名.ifm`是在两种结构中都会存在的文件,为每张表保存表结构等信息.

###### 重做日志文件(redo log file)`

- 由`Mysql`的**存储引擎层产生的，用于记录数据修改**的日志文件.严格来说`redo log buffer`和`redo log file`都属于重做日志.

- 默认情况下,`InnoDb`存储引擎的数据目录下会自动生成两个名为`ib_logfile0`和`ib_logfile1`的文件,这就是**重做日志文件**.
- 它们记录了对于`InnoDB存储引擎`的事务日志,当数据库挂了之后也可以使用该文件恢复到挂之前的状态,**保证事务的持久化特性**
- 特别要提的是**重做日志缓冲写入磁盘时,是按照一个扇区的大小(512字节)写入的,因为扇区是写入的最小单位,所以此次写入是100%成功的**,也就不需要用到`double write`的特性.
-  以下为重做日志相关属性的参数:
  1. **指定每个日志文件大小**: innodb_log_file_size
  2. **指定每个日志组中的日志数**: innodb_log_files_in_group
  3. **指定镜像日志文件组数目**: innodb_mirrored_log_groups
  4. **指定日志文件保存路径**: innodb_log_group_home_dir
- 注意:因为**`InnoDB`采用循环写入的方式,即在每个日志文件中以写满为条件切换,所以日志文件大小不能设置的太小,否则会导致频繁的切换日志文件,同时也会频繁触发上文所说的`Async Checkpoint`机制,最终导致性能降低**.

###### 回滚日志(undo log)

- `undo log`记录了事务对数据库的所有修改(更新,删除等)操作,**用于在事务执行失败以及ROLLBACK后的回滚操作，也是多版本并发控制`MVCC`的根源**
- 和`redo log`不同的是,**`undo log`是用来存放旧版本的数据，而且日志存放在共享表空间内的undo段**,



#### InnoDB逻辑存储结构

![img](https://github.com/CheNbXxx/StrugglingInJava/blob/master/img/InnoDB%E7%9A%84%E9%80%BB%E8%BE%91%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84.png)

- 在`InnoDB`中,表都是以`索引组织表`形式,即**按找主键顺序组织存放的**.在没有设定主键的情况下,也会按照如下顺序自主生成:
  1. 查找表中**唯一非空索引**,若单一则直接作为主键,若有多个则选择索引定义顺序选取第一个作为主键.
  2. 若没有**唯一非空索引**,则自动创建6字节大小的指针作为主键.
- 上文说到,**`InnoDB`中所有的数据相关信息都存在表空间文件中**,其中**表空间(tablespace)**就是`InnoDB`存储结构的最高层,从图中也可以看出往下是**段(segment) -> 区(Extent) -> 页(Page) -> 行(Row)**.

###### 段(Segment)

- `InnoDB`的段包括`数据段,索引段以及回滚段`.
- `InnoDB`中的段都是引擎自己管理的,我们不能也不需要去插手管理.

###### 区(Extent)

- 区是由**连续页组成的定长为1MB的空间**

###### 页(Page)

- 页是`InnoDB`管理磁盘的最小单位.
- 页的类型有:
  1. 数据页
  2. undo页
  3. 系统页
  4. 事务数据页
  5. ....

###### 脏页(Dirty Page)

- 所谓的`脏页`,就是缓冲池中被修改过,但未刷新回磁盘的数据页.由此机制<font size="2">(修改的数据以页为单位刷新回磁盘)</font>也可以佐证`页`就是`InnoDB`磁盘管理的最小单位.也没又说`脏行`的.

###### 行(Row)

- `InnoDB`存储引擎是面向列(row-oriented)的,也就是说数据是按行来进行存放的.每个页最多存7992条记录.<font size="2">(书上原话)</font>

#### 索引

- `InnoDB`存储引擎支持的索引类型有:
  1. 哈希索引
  2. 全文索引
  3. B+树索引

##### 哈希索引

- `InnoDB`存在被称为**自适应哈希索引**的特性,因此哈希索引是由引擎自主管理的,会根据表的情况自动生成,不需要人为干预.

##### B+树索引

-  B+树索引通过构造类似B+树的构造类型,根据其K/V结构快速定位查找数据,是目前关系型数据库中最为常用,也最为有效的一种索引.
- 注意:**B+树并不能定位到一个给定键值的具体行,而是找到该数据行所在的页,把该页读入内存后,在进行查找.**



#### 锁

- **`InnoDB`同时支持`行锁和表锁`,同时提供`一致性非锁定读`.**
- 锁的对象是事务,用来锁定的时数据库中的对象,在`InnoDB`中就是表和行.

##### 锁分类

- 按照粒度分`InnoDB`中的锁可以分为表锁和行锁,按照锁的特性分`InnoDB`中的锁又可以分为**共享锁(X)和排它锁(X)以及意向锁(IS,IX)**,其中共享锁和排它锁都是行锁,而意向锁都是表锁.
  - 共享锁(S): 允许事务读取某行数据
  - 排他锁(X): 允许事务删除或更新某行数据
  - 意向锁(IX,IS):  允许事务获取表中记录的X或S锁

<font size="2">下图为锁之间的兼容性</font>

|      | X      | S      |
| ---- | ------ | ------ |
| X    | 不兼容 | 不兼容 |
| S    | 不兼容 | 兼容   |


|      | X          | S      | IX     | IS     |
| ---- | ---------- | ------ | ------ | ------ |
| X    | 不兼容     | 不兼容 | 不兼容 | 不兼容 |
| S    | 不兼容     | 兼容   | 不兼容 | 兼容   |
| IX   | 不兼容     | 不兼容 | 兼容   | 兼容   |
| IS   | **不兼容** | 兼容   | 兼容   | 兼容   |

- `InnoDB`存储引擎支持多粒度的锁定,即允许行级锁和表级锁同时存在.
- 当事务想要对某行记录上X锁时,必须先对对应的表上IX锁,之后在对记录上X锁.

##### 一致性非锁定读

- 一致性非锁定读是指`InnoDB`存储引擎通过**行多版本控制**的方式来读取当前执行时间数据库中的行数据.注意:**一致性非锁定读只发生在`READ COMMITTED 和 REPEATABLE READ两种事务隔离级别下**.
- 如果想要读取的行记录被另外一个事务上锁导致暂时无法访问,此时`InnoDB`并不会阻塞读取线程,而会直接返回一个快照数据,**快照数据即为之前版本数据,由`Undo`实现.**,同时这种访问模式也能大大提高数据库的表并发性.
- **行多版本控制技术**就是指一个行记录可能会有多个快照数据,而由此带来的并发控制也称为多版本并发控制(MVCC).

##### 一致性锁定读

- 因为在`READ COMMITTED`和`REPEATABLE READ`两种隔离级别下,一致性非锁定读是默认设置,所以此时就特殊的语句显式上锁.
  - `SELECT...FOR UPDATE`
  - `SELECT...LOCK IN SHARE MODE`
- `FOR UPDATE`会为匹配的记录上X锁,`LOCK IN SHARE MODE`会为匹配的记录上S锁.
- 注意:**`InnoDB`会根据查找记录的方式决定上行锁还是表锁,如果走索引上的就是行锁,如果没有走索引上的就是表锁**
- 此处有个疑问:**按书中所说,再给行记录上X锁之前还是会先对表上IX锁,这要是算行锁的话,表锁是上的哪种锁,还是意向锁吗**?

##### AUTO-INC Locking

- **用来保证自增长列赋值正确性的一种特殊的表锁**
- 为了保证自增长列数值的正确性,每个包含自增长列的表都会有一个`自增长计数器`,插入时会根据该计数器的值自增后赋值给自增长列属性.
- 为了数据库的性能,`AUT-INCLocking`并非是在事务执行完毕之后才释放锁,而是在相关的插入SQL语句执行完后就释放.
- `MySQL 5.1,22`版本之后,`InnoDB`提供了另外一种轻量级互斥量的实现方式.<font size="2">(此处不详细展开)</font>



#### 锁问题

对于数据库来说往往都存在以下几种问题:

1. 脏读

   ​	当一个事务修改数据时先是修改缓冲池中对应的数据页且没有提交,也就是所谓`脏数据`,此时若是没有锁另一个事务读取时便会读取到这行`脏数据`,

2. 丢失更新

   ​	指的是一个事务的更新在事务提交前被另外一个事务的更新操作覆盖.	

3. 不可重复读

   ​	指的是两次读取的数据会有不一样.

   ​	`不可重复读`和`脏读`的区别仅在于`脏读`读取的是脏数据,就是修改数据的事务并没有提交,而`不可重复读`读取的是事务提交之后的数据.

4. 幻读

   ​	`幻读`和`不可重复读`一样都是两次读取的数据不一致.

   ​	`MySQL`的官方文档中好像并没有区分`不可重复读`和`幻读`,甚至统称为`幻读`. 但在我平常理解中`不可重复读`针对的是update操作,而`幻读`是delete和insert操作.

   ​	

#### 锁的实现算法

`InnoDB`中锁的实现有以下三种算法:

1. `Record Lock` - 记录锁
2. `Gap Lock` - 范围锁
3. `Next-Key Lock` - `Record Lock` + `Gap Lock`

##### Record Lock

- 记录锁锁住的是**某一行记录**,可以用来保证单行记录的并发安全.
- 可以用来解决`脏读`问题

##### Gap Lock

- 范围锁仅仅锁的是一个范围,并不会包含记录本身.
- `Gap Lock`的作用是为了阻止多个事务将记录插入到同一范围内.

##### Next-Key Lock

- `Next-Key Lock`就是`Record Lock`和`Gap Lock`两种锁的结合.
- 其设计初衷就是为了解决幻读问题.
- 另外若查询的列为唯一索引,`Next-Key Lock`将会降级为`Record Lock`.
- 隔离级别为`REPEATAGLE READ`时默认采用`Next-Key Lock`算法,而在`READ COMMITTED`时仅采用`Record Lock`算法.



#### 事务

- **事务**是数据库系统区别于文件系统的重要特点.

- 在`InnoDB`中事务是访问或更新数据库中各种数据项的一个程序执行单元.

- 通常事务都具有`ACID`四种特性,`InnoDB`中的事务设计是全部满足的

  - Atomicity 原子性

    ​       事务中的所有sql要不全做,要不全不做.

  - Consistency 一致性

    ​      事务开始前和事务结束后,数据库的完整性约束没有被破坏.

  - Isolation 隔离性

    ​       事务与事务之间相互隔离,在提交之前互相不可见.

  - Durability 持久性

    ​	事务造成的影响是永久的.

##### 并发情况下事务的问题

1. 脏读
   - 一个事务读取到另外一个事务没有提交的数据.
   - `脏数据`是指在缓冲中已经修改,但事务并没有提交的数据.
2. 不可重复读
   - 事务的两次相同读取操作中间,另外一个事务对读取记录的修改导致前后两次读取内容不同.
3. 幻读
   - 我的概念里一直是觉得`幻读`和`不可重复读`差不多的.
   - `幻读`侧重于`删除和新增`导致数据库中行记录总数产生变化的修改.

##### `InnoDB`事务的实现

- 事务的隔离性是由`InnoDB`的锁机制实现的.
- 事务的原子性和持久性由`redo log`实现.
- 事务的一致性由`undo log`实现.
- `redo log`重做日志,在`InnoDB`中,事务的提交过程遵循所谓`Force log at Commit`机制,即当事务提交的时候,必须先将事务相关的日

##### 事务的隔离级别

1. `READ UNCOMMITTED`   未提交读
   - 事务能读取到另外一个事务没有提交的修改,是最低的隔离级别.
2. `READ COMMITTED`  已提交读
   - 事务只能读取到另外一个事务没有提交的修改.
3. `REPEATED READ`  可重复读
   - 将数据库状态固定位开始事务时的状态,以此避免脏读,不可重复读.
   - `InnoDB`中因为在该隔离级别时引入了`Next-Key Lock`,所以在该隔离级别下就不存在幻读问题了.
4. `SERIALIZABLE` 串行化
   - 事务完成串行化运行,读写相互阻.

##### 事务的阻塞和死锁问题

###### 阻塞

- 当两个事务竞争同一把锁时,得到锁的事务进入执行,未得到锁的事务就会被阻塞,等待锁的释放.
- 事务不可能不限时的阻塞下去,`InnoDB`中默认的超时时间为50s,相关操作可用以下参数控制:
  - `innodb_lock_wait_timeout`   事务的超时时间
  - `innodb_rollback_on_timeout`    超时之后是否回滚
- 注意:**`InnoDB`默认超时是不会回滚的,或者说大部分情况下对异常都不会回滚**,

###### 死锁

- 和操作系统中的死锁类似,两个事务相互等待对方手中的锁释放,导致相互阻塞.
- 虽然`InnoDB`不会回滚大部分的异常,但是死锁是特殊的,`InnoDB`发现死锁的情况时,会立即回滚一个事事务.
- `InnoDB`存储引擎采用了普遍的`wait-for graph`等待图算法来检测死锁.



---

#### 相关问题

##### B+树在InnoDB存储引擎中的使用

- **B+树**在`InnoDB`中的主要作用就是组织索引.

- 首先要明确,和`MyISAM`的数据和索引分离存储不同,`InnoDB`中数据是和索引一起存储的,数据页本身也就是主键的索引页.<font size="2">(所以InnoDB硬性要求主键,没有还会自己帮你生成)</font>
- 因为采用`索引组织表`和`聚集索引`的存储格式,`InnoDB`会为每张表的主键创建一颗`B+树`,而且这棵`B+树`的叶子节点中就存放着整张表的记录数据.
- 辅助索引页中,`InnoDB`会以索引列创建`B+树`,但叶子节点并不会包含行记录的全部数据,而是**主键***,所以通过辅助索引查找时,最终都会回归主键索引.

