- 最近真的是累啊，感觉好久没有早下班了。

![image-20191109232700038](https://chenbxxx.oss-cn-beijing.aliyuncs.com/redis_sync_sentinel.png)

<!--more-->

### 一、Redis的主从复制模式

Redis中可以通过`SLAVEOF <ip> <port>`指令或者配置文件`slavof <ip> <port>`的方式，让本服务器去复制另外一个服务器。

被复制的服务器称为主服务器，复制的服务器则称为从服务器，以此形成一种主从关系(Master-Slave)。

建立主从关系之后，从服务器不再(也不能)执行写命令，而是完全同步主服务器的数据(就算发现AOF或者RDB文件中有过期的键也不能删除，只能等主服务器的同步)。

指令`info replication`，可以单独查看服务器此时的主从信息。如下：

![image-20191109232601445](https://chenbxxx.oss-cn-beijing.aliyuncs.com/redis_info_replication_master.png)

该种主从复制模型非常适合读多写少的环境，而且仅从主服务器写入一定程度上也不需要担心数据一致性问题。



#### 1. 复制

一般来说，复制分为首次的**数据同步**以及后续的**命令传播**两个阶段。

新旧版本的复制功能主要的区别就在于数据同步。

以下也仅包含数据同步阶段的流程



#### 2. 旧版的复制功能

旧版的复制功能依托于`Sync`命令，由从服务器发送给主服务超过半数主观下线器表示需要同步数据。

主服务器接收到`Sync`命令之后，执行`BGSAVE`命令生成RDB文件，并在此时开启**命令缓冲区**。

命令缓冲区会记录所有执行的写命令。

![image-20191109154905723](https://chenbxxx.oss-cn-beijing.aliyuncs.com/Redis_SYNC_%E6%B5%81%E7%A8%8B.png)

BGSAVE执行完之后，会将生成的RDB文件发送给从服务器(此时如果于多个从服务器连接，RDB文件可以直接共享)。

从服务器在接收到主服务器发送的RDB文件之后，会清空所有本机的数据，载入RDB文件中的数据。

之后主服务器还会将缓冲区中的数据发送到从服务器，从服务器执行完缓冲区中的写命令，就达到了和主服务器的完全一致。

一致之后，主服务器如果执行写命令，也会发送给从服务器。主从复制相关的数据结构
Redis设计与实现中题

在主服务器执行完写命令，且未传播期间，从服务器和主服务器其实还处于数据不一致的状态。

)小声BB，是不是可以用二阶段提交来作强一致性的需求。



#### 3. 旧版复制功能的缺陷

旧版复制功能的缺陷主要集中在第一步，也可以说是`Sync`命令。

Sync本身命令效率就不高不说，在从服务器断线重连之后还需要重新生成RDB文件并重新载入，效率实在有点低。

为此在Redis2.8版本之后，新增加了一个`PSYNC`命令。

`PSYNC`命令完整的形式是`PSYNC <runid> <offest>`



#### 4. 新版的复制功能

新版的复制功能将旧版的复制按情况划分，分为**完整重同步**以及**部分重同步**。

从服务器第一次连接上主服务器时肯定执行的是完整重同步和旧版没区别，但是在断线重连之后，就有区别了。



#### 5. 部分重同步相关的概念

1. 复制偏移量

   按照字面意思也很好理解，是主从服务器各自维护的以字节为单位的属性，表示复制的进度。

   比如当前主服务器的复制偏移量为10000，在发送了50个字节的内容之后，就变为了10050，可以认为是主从服务器数据不一致性程度的表示。

2. 复制积压缓冲区

   复制积压缓冲区是由主服务器维护的一个固定长度的FIFO队列。

   该队列会缓存近期主服务器所执行的写命令。

   默认大小为1MB

3. 主服务器 run ID

   run ID唯一标识一个主服务器。

   实际上不论主从在服务器启动时都会生成一个run ID，由40位随机的16进制字符组成。

   此处的run ID是在从服务器连接到主服务器是由主服务器下发的自身的run ID。
   
   

#### 6. 新版本的复制流程

接收到`PSYNC`命令之后，主服务器会判断，如果是第一次同步，则会直接走旧版`SYNC`的逻辑。

如果是断线重连的情况则会根据双方的`复制偏移量`以及`积压缓冲区`长度的对比，来决定是部分还是完整重同步。

复制积压缓冲区里的每个字节都会有自己的偏移量属性，主服务器会判断`PSYNC`传过来的从服务器复制偏移量是否还在缓冲区中。

如果此时缓冲区中最小的偏移量都大于从服务器的复制偏移量，则还是会走旧版的`SYNC`逻辑。

如果从服务器的复制偏移量仍存在于积压缓冲区则进行部分重同步。

对了，在复制流程开始前还还会判断主服务器的run ID，如果run ID与当前的服务器不匹配，则说明从服务器之前复制的是另外一台主服务器，则直接开始完整重同步。

**部分重同步就是发送积压缓冲区中从服务器复制偏移量之后的所有数据。**



### 二、 Sentinel 哨兵模式

`Sentinel`是Redis的高可用解决方案，仅仅依靠主从复制在主服务器宕机之后就表示主服务器所在的整个模块都是只读状态(Redis不存在主主复制的模式)，无法写入或更新数据。

`服务器Sentinel`就是指一个或者多个Sentinel服务器(Sentinel就是特殊的Redis服务器)组成Sentinel系统，并监视一个或多个的主服务器及其从服务器。

在主服务器宕机时，激活故障转移功能，从该主服务器下的从服务器中选取一台作为新的主服务器，从而保证整个系统在短时间内恢复可用。

`Sentinel`就是特殊的`Redis`服务器，和普通的`Redis`服务器共用一部分代码，但又有一套自己的数据结构和指令集(所以GET/SET等命令也就不可用)。



#### Sentinel建立的相关流程

##### 1. 根据配置，初始化Master服务器连接

`Sentinel`服务器初始化时就会在自身的`sentinelRedisInstance.masters`中记录下所监视的所有主服务器信息。

连接Master时，`Sentinel`不仅仅会建立普通的**命令连接**，也会建立一个**订阅连接**，用于订阅主服务器的`_sentinel_:hello`频道。

创建**订阅连接**的原因除了订阅之外，还因为`Redis`的发布订阅模块并不提供ACK机制，消息发送时如果因为网络抖动而未到达`Sentinel`，那就会直接丢失这条消息。

至此`Sentinel`就有了包含主服务器的拓扑信息。



##### 2. 获取主/从服务器信息

`Sentinel`会以**一定的频率**向所监视的主服务器发送`INFO`命令，来获取对应主服务器的消息。

获取到的信息里面包括主从消息`Replication`，因此也就获取到了从服务器的信息。 



##### 3. 连接从服务器

 在上一步获取到从服务器的信息以后，`Sentinel`同样也会和每个从服务器建立两条连接。

并按一定频率发送`INFO`命令，获取从服务器的具体信息。

至此`Sentinel`的当前网络结构拓扑中新增了从服务器。



##### 4. 向订阅的所有主从服务器的`_sentinel:hello_`频道发送消息

```
PUBLIC _sentinel:hello_  "s_ip,s_port,s_runId,s_epoch,m_name,m_ip,m_port,m_epoch"
```

消息中包含的分别是**Sentinel的ip，端口，runId，年代，主服务器的name，ip，端口，年代**

注意向从服务器发送的消息，是他们所复制的主服务器的信息。

同样的消息是以一定的频率循环发送的。



##### 5. 接收`_sentinel:hello_`频道的消息

通过频道的订阅，`Sentinel`会收到所有监视该主节点的其他`Sentinel`的消息。

以此为根据`Sentinel`会在该主节点的数据实例中记录下所有监听他的`Sentinel`的相关信息。



##### 6. 和其他的`Sentinel`建立命令连接

`Sentinel`之间不会建立订阅连接，仅仅只有命令连接。

至此，`Sentinel`系统完整的拓扑图构造完成。

和主服务器建立连接没得说，监视的就是主服务器的情况。

和从服务器建立连接则是为了故障转移之后的选主，需要和从服务器交互。

和其他的`Sentinel`则是因为选主，不可能在失效之后每个`Sentinel`各自选择一个从服务器升为主服务器。

![image-20191109233459918](https://chenbxxx.oss-cn-beijing.aliyuncs.com/Sentinel%E7%BB%93%E6%9E%84.png)



#### 故障转移相关

##### 1. 主观下线检测

 **`Sentinel`每秒都会向命令连接(包括主从服务器以及其他Sentinel)发送一个`PING`命令**,并通过返回确定对方当前的状态。

有效返回有以下几种：

1. `PONG`
2. `LOADING`
3. `MASTERDOWN`

如果对方服务器在`down-after-milliseconds`毫秒内(配置文件中指明)，没有返回一个有效返回，则当前服务器认定对方为主观下线，并修改实例对象中的状态。

**如果是从服务器，那么在修改完对象中的状态后，就不会有别的操作。**

从服务器重新开启在线状态就需要通过`Sentinel`向其主服务器发送的`INFO`命令中的返回信息。

如果是主服务器则进入客观下线检测的流程。



##### 2. 客观下线检测

`Sentinel`会发送如下命令查询别的`Sentinel`服务器是否认为该主服务器已经下线：

```
SENTINEL is-master-down-by-addr ip port epoch runId
```

在接收到超过`quorum`(配置文件配置)的确认下线之后，当前`Sentinel`才会认为目标服务器却是下线了，并开启以下的故障转移流程。

前三个参数都是下线的Master的，但是run Id不是。

run Id可以为`*`表示此次仅为客观下线检测，也可以为当前`Sentinel`的run Id，该参数用于此后的选举过程，表示希望选举自己为头节点。

对于以上命令，接收的`Sentinel`会回复三个参数：

1. `down_state`   -   目标主服务器下线状态，1为已下线，0为未下线
2. `leader_runid`  -   表示当前`Sentinel`选定的头节点的run id，`*`表示此次仅为客观下线检测
3. `leader_epoch`  -   表示选定的头节点的 epoch



##### 3. 选举头节点

首先，监视下线节点的所有`Sentinel`会协商，选举出一个领头节点，来完成接下来的故障转移功能。

Redis的选举算法是对`Raft算法`的具体实现。

`Raft算法`是一种分布式一致性共识算法，如果不了解`Raft算法`，可以参考以下的网站：

[Raft算法的动画演示](http://thesecretlivesofdata.com/raft/)

每个`Sentinel`都保留着监视下线`master`的其他`Sentinel`的信息，也就方便协商。

选举有以下规则：

1. 每次选举不论是否成功，当前`epoch`自增一次。
2. 每次选举，每个`Sentinel`都只能选举一个头节点，且不能修改。
3. 每个`Sentinel`都有资格成为头节点。
4. 每个发现客观下线的`SENTINEL`都会要求其他节点选举自己为头节点。
5. 如果超过半数以上的`Sentinel`选了同一个`Sentinel`，那么选举成功，该`Sentinel`成为头节点。
6. 给定时限之内没有结果，则当前选举失败，开启下一轮选举。
7. `SENTINEL is-master-down-by-addr`作为`Sentinel`节点间的通信。



##### 4. 故障转移

由上一步选举产生的头节点执行故障转移操作。

**选择新的主服务器**

从下线主服务器的所有从服务器中挑选一个作为新的主服务器，发送`SLAVEOF NO ONE`命令，并以每秒一次的频率发送`INFO`命令，监控该从服务器当前的状态。

`SLAVEOF NO ONE`并不一定能很快到达并执行，所以需要状态监控。

![image-20191109233931424](https://chenbxxx.oss-cn-beijing.aliyuncs.com/redis_info_replication_slave.png)

就是上图中的`role`字段从`slave`变为`master`，表示从服务器已经变为主服务器。

**修改其他从服务器的复制目标**

直接发送`SLAVEOF ip port`命令，将其他从服务器的复制目标指向新的主服务器

**将旧主服务器降为从服务器**

和第二步的发送命令不同，此时旧服务器可能还处于掉线状态并没办法接受到`SLAVEOF`命令，所以此处的修改仅仅在`Sentinel`内部的数据结构中。