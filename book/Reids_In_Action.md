## Redis实战

感觉实战里面很多的东西没必要第一时间就学，所以看的都是基础为主。

还有类似分布式锁等非常非常重要的组件功能。



### Redis基础

Redis是一种**内存型K/V型NoSQL（非关系型数据库）**。

详细的命令可以直接从中文官网看：[Redis命令](https://redis.io/commands)



#### 基础命令

- 省略在基础不过的GET、SET命令

##### 过期时间相关指令

| 命令    | 作用             |
| ------- | ---------------- |
| EXPIRE  | 设置键的过期时间 |
| PERSIST | 移除键的过期时间 |
| TTL     | 查询剩余过期时间 |

- 以上指令都还有一套用于UNIX时间的命令版本

##### 事务相关命令

| 命令 | 作用 |
| ---- | ---- |
|      |      |
|      |      |
|      |      |

​		Redis中的事务基本等同于MYSQL的事务

​		由MULTI和EXEC包裹的命令会一次性到服务端执行，保证命令的原子性等

​		**事务命令也可以用来加速客户端的效率，将多次请求打包在MULTI和EXEC中执行可以减少其中命令和结果在网络中的传播时间，提高效率**



#### Redis的基础数据结构

##### String - 字符串

​		Redis中的字符串类似于C语言中的String

​		字符串可以存储以下三种类型:**字节串，整数，浮点数**

 - Redis字符串可以看作二进制位串（Bit string）

   | 命令          | 作用                       |
   | ------------- | -------------------------- |
   | GETBIT/SETBIT | 获取/更新二进制位串的某位  |
   | BITCOUNT      | 统计二进制位串中1的个数    |
   | BITOP         | 位运算（AND，OR，XOR，NO） |

   - 二进制位串可以作登录统计，每日签到等节省空间也方便计算

- 常用命令

  | 命令              | 作用       |
  | ----------------- | ---------- |
  | INCR/DECR         | 自增/自减  |
  | APPENT            | 字符串拼接 |
  | GETRANGE/SETRANGE | 子串操作   |

  - 虽然INCR/DECR都为原子操作，但对客户端来说也并非线程安全（以前记得一句话，现在读起来感觉有问题）。

##### List - 列表

- Redis的列表允许用户从序列的两端推入或弹出数据（类似于堆栈）

- 常用命令：

  | 命令        | 作用                                             |
  | ----------- | ------------------------------------------------ |
  | LPUSH/RPUSH | 从左边/右边推入数据                              |
  | LPOP/RPOP   | 从左边/右边弹出数据                              |
  | LRANGE      | 获取一段范围的数据                               |
  | LTRIM       | 修剪列表，只保留start和end之间的元素（左闭右闭） |

  ​		借由以上命令,Redis的List完全可以作为消息队列使用

  ​		另外还有部分阻塞式POP命令，BLPOP/RLPOP，若队列中元素为空则阻塞TIMEOUT秒

- List间的元素交流

  | 命令       | 作用                      |
  | ---------- | ------------------------- |
  | RPOPLPUSH  | 弹出右边元素,推入目标左边 |
  | BRPOPLPUSH | 阻塞式                    |

  ​		以上命令可能不会常见，但将POP和PUSH合成一个命令之后省去了客户端自己POP数据的步骤，在元素移动时效率能高很多



##### Set - 集合

​		Redis的集合以无序且无重复的方式存储不同的元素。

- 常用命令：（相比于前两个结构来说集合对我来说陌生多了）

  | 命令        | 作用                                      |
  | ----------- | ----------------------------------------- |
  | SISMEMBER   | 检查元素是否存在于集合                    |
  | SCARD       | 返回集合中的元素数量                      |
  | SRANDMEMBER | 随机返回一个或多个数字，count为正时不重复 |
  | SPOP        | 随机弹出一个元素，并返回                  |
  | SMOVE       | 原集合中包含则将元素移动到目标集合        |

- 多集合交互命令

  | 命令                 | 作用             |
  | -------------------- | ---------------- |
  | SDIFF、SDIFFSTORE    | 差集、差集并转存 |
  | SINTER、SINTERSTPORE | 交集、交集并转存 |
  | SUNION、SUNIONSTORE  | 并集             |

  



##### Hash - 散列表

​		散列可以让用户将多个键值对存储到一个Redis键里

​		概念上完全可以理解为Java中的HashMap，可能实现方式不一样

- 常用命令：

  | 命令                  | 作用                     |
  | --------------------- | ------------------------ |
  | HMSET/HMGET/HGET/HSET | 设置或获取值             |
  | HDEL                  | 删除                     |
  | HLEN                  | 返回键值对数目           |
  | HKEYS/HVALS/hGETALL   | 获取所有的键、值、键值对 |
  | HEXISTS               | 检查给定键是否存在       |
  | HINCRBY               | 指定键增加指定值         |

  ​	在我的看法里Hash的作用应该是这些结构里面最大的。





##### Zset - 有序集合

​		有序集合从概念上来讲就是在集合的基础上为集合中的每个元素映射一个分值，使其有序。

​		有序集合提供了分值处理命令以及根据分值大小有序的获取或扫描成员和分值的命令

- 常用命令	

  | 命令      | 作用                               |
  | --------- | ---------------------------------- |
  | ZCARD     | 获取有序集合中的成员数量           |
  | ZCOUNT    | 返回分值处于指定参数之间的元素个数 |
  | ZRANGE    | 返回排名处于指定参数之间的元素     |
  |           | 处于分值处于参数之间的元素         |
  | ZSCORE    | 返回元素分值                       |
  | ZADD/ZREM | 新增、删除                         |

  有序集合应该是我最不熟悉的部分了

  可以作线上的排序，例如热度文章排行，游戏中的战力名次排行等等



### Redis的持久化

Redis提供了以下两种持久化的操作：

​		**快照（snapshotting）**，简单来说他可以将某一时刻中Redis里的所有数据写入硬盘，确保断电不丢失

​		**只追加文件（append-only file AOF）**，会在执行命令的时候就将命令复制到硬盘，恢复即为重新执行命令

Redis的两种持久化各有各的优缺点，组合在一起可以大大增强系统崩溃的抵抗能力。

#### 快照（snapshotting）

​		类似于MYSQL中的快照，Redis中的快照也可以理解为一个临时创建的副本。

​		根据Redis的**dbfilename**配置项，快照将被写入指定的文件，文件存放在**dir**配置项指定的路径。

​		**Redis崩溃之后的恢复会导入最后一次快照的数据**。所以缺点也很明显：

​		恢复会丢失上次快照到崩溃时间的所有数据，但当数据量很大的时候配置频繁的快照操作会让Redis的性能大打折扣。

##### 创建快照的方法

  1. **BGSAVE**

     服务端接收到**BGSAVE**的命令之后，会`fork`创建一个子进程来负责快照的创建和落盘，父进程继续响应客户端的骑牛。

		2. **SAVE**

     **SAVE**就是**BGSAVE**的阻塞版本，在**SAVE**命令完成之前Redis服务端不会响应任何的命令

		3. 配置项`save`

     `save 60 10000`  表示60s内有10000次的写入就执行**BGSAVE**

		4. **SHUTDOWN**和**TERM**

     在关闭服务器之前会执行**SAVE**，将当前数据全部落盘

		5. **SYNC**

     **SYNC**用于集群间的数据同步，从服务器向主服务器发送这个命令之后，如果当前主服务器的快照过旧就会触发**BGSAVE**命令

##### 验证快照文件命令

​	`redis-check-dump`





#### AOF

​		**AOF**模式下，Redis会将**写命令**都写入AOF文件的末尾。

​		`appendsync` - 控制AOF频率的配置项，包括`always`，`everysec`，`no`  

​		**相对于快照持久化的方式来说，AOF持久化能在不影响服务器性能的情况下尽量的减由于崩溃而损失的数据（崩溃**      

**只会损失上次AOF写入之后的数据），但AOF也有缺点 - 数据恢复，和快照的恢复不同AOF的恢复需要重新执行文件中的**      

**指令，如果AOF文件过大会导致恢复的时间也会被拉长到无法接受，另外AOF也会不断消耗硬盘的空间**

​			为了解决AOF文件体积问题，Redis引入了`BGREWRITEAOF`命令：该命令会通过移除AOF文件中冗余的命令来尽 

可能的缩小AOF文件体积，同时也减少了其中写命令的数量，降低恢复消耗的时间。

###### 自动BGREWRITEAOF的配置项

​		`auto-aof-rewrite-percentage` 

​		`auto-aof-rewrite-min-size`

```shell
// 在文件体积大于64mb,并且比上一次重写之后大一倍的情况下执行BGREWRITEAOF
auto-aof-rewrite-percentage 100 
auto-aof-rewrite-min-size   64MB
```

##### 验证AOF文件的命令

​		`redis-check-aof`

​		该命令会扫描AOF文件直到第一个错误命令，并删除其后的所有命令。





### Redis的主从复制

​		在集群环境下，一般采用**主从**的形式，主服务器会向从服务器发送更新，并使用从服务器来处理所有的读请求，

而写命令全在从服务器完成。

​		这时候就需要复制（replication），复制可以让其他的服务器也有一个不断更新的数据副本，保证数据的正确性。

​		在接收到主服务器发送的数据初始副本之后，客户端每次向主服务器进行写入时，从服务器都会**实时**更新。



#### 主从复制的配置 

##### `slaveof host port`配置项

​		Redis服务启动时检测到有该项配置，会直接根据指定的host和port连接到主服务器。

##### **slaveof**命令		

​		如果Redis服务器已经启动可以，输入**slaveof host port**命令指定连接到的主服务器，也可以使用**slaveof no one**  

来解除主从关系。

​		**Redis连接到主服务器之前会清除所有当前数据**



#### Redis主从复制的过程



  1. **从服务器（从）连接到主服务器（主），发送`SYNC`命令进行同步**

  2. **主服务器接收到后，如果快照数据过旧(我也不知道怎么定义过旧)就会触发BGSAVE异步创建新的快照,此时从服务器**

     **会根据配置决定是否仍然响应命令请求。**

		3. **BGSAVE执行完毕之后，主服务器会向从服务器发送最新的快照，从服务器会清空当前所有数据，载入最新的快照**
	
		4. **在快照发送期间，主服务器仍然会使用缓冲区记录写命令，并在发送之后继续发送写命令。**
	
		5. **从服务器载入完毕完成同步之后，主服务器每完成一个写命令就会向从服务器发送相同的命令**

     

     

​	以上过程中产生的主服务器的快照文件是可以公用的，向上面说的主服务器接收到**SYNC**命令之后会先检查快照的版

本，若为最新版本则不需要**BGSAVE**，而选择直接发送当前快照。

​	**Redis不支持主主复制**		



书里好像没有看到哨兵的相关东西，有空翻博客补充一下



### Redis在程序中的使用

​		这部分的内容偏实战了，我不确定对现在的我是否有用，或者说这些东西现在是否还能用，所以只看了**分布式锁**相关的

略过的内容有以下：

			1. Redis记录日志
   			2. Redis实现计数器 - 这个在获取分布式唯一Id的时候也算是一种实现方法
      			3. 查询IP所属 - 需求太窄，用到再看也行
         			4. 服务注册与发现 - Zookeeper能完美代替了
            			5. 前缀自动匹配程序 -  稍微看了一点
               			6. 消息任务队列
                  			7. 文件分发



#### Redis实现分布式锁

​		线上开始多实例配置之后，JDK的单机锁（Lock、Synchronized）的作用就有限了，而在分布式锁方面我第一个接触到的就是Redis了(后面还有Zookeeper啥的).

​		Redis实现分布式锁并不难，SET [NX] [EX] 天生就合适，还自带超时时间，但是在此之外还有一些别的问题：锁的

重入性，锁的误撤销

​		所以在直接SET的基础上，为每个键分配一个唯一ID，就我现在的项目而言因为本身就会为每个请求线程分配一个唯

一ID，所以实现起来方便很多。

​		首先在释放Redis锁之前会检查一遍唯一ID，只有唯一ID对的上才会允许消除。

​		其次，在获取锁的时候会先获取当前的锁对象比较唯一ID，唯一ID相同返回`true`表示锁重入成功。

但是因为每个锁的过期时间设置的都是一样的，所以任务时间过长但锁已经释放的问题还没想到解决方法。



### Redis的短结构

​		短结构是一种Redis采用的降低内存占用的有效方法。

​		对应不同的结构也有不同的短结构：

		1. 压缩列表 - 列表，散列，有序集合
  		2. 整数集合 - 集合

##### 压缩列表 - ziplist

​		对比于列表等基础结构来说，压缩列表的结构更为紧凑。

​		**与Redis在通常情况下使用双链表表示列表，使用散列表表示散列，使用散列加上跳跃表表示有序集合不同，压缩列**

**表会以序列化的方式存储数据，这些序列化数据每次被读取时都需要被解码，写入时也需要进行编码。**

​		相关配置：

```she
// 列表结构使用压缩列表的阈值
list-max-ziplist-entries 最大元素数量
list-max-ziplist-value	 单节点最大体积(字节)	

hash-max-ziplist-entries 
hash-max-ziplist-value

zset-max-ziplist-entries 
zset-max-ziplist-value
```



##### 整数集合 intset

​		如果集合中的元素都能用十进制表示，并且数量少于阈值的时候，Redis就会以整数集合的形式存储。

相关配置项：

```she
// 集合采用整数集合存储的阈值
set-max-intset-entries 512 元素数量 
```



##### 短结构的缺点

​		短结构的设计单纯是为了减少Redis中的内存占用，随着短结构中元素的增加，这些数据的查询也会越来越慢。

​		因此，**当短结构中的元素数量或者体积超过阈值之后，会立马转变为正常的结构。**

​		从短结构到正常结构的过程是**不可逆的**，转变为短结构后就算清空了数据之后的插入也会用正常结构。



