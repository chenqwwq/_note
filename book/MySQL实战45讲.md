# MySQL实战45讲

## 1. MySQL的基础架构

`MySQL`的总体结构包括Server层和存储引擎，Server层包括连接器，查询缓存(v8中完全删除)，分析器，优化器和执行器。

连接器管理连接和权限验证，分析器包括词法和语法分析，优化器预判执行效率选择查找方式(选择索引，所以走不走索引最终还是决定于优化器)，执行器连接存储引擎，返回结果。

查询缓存被删除的原因，主要还是效率低下，利用率也低，好像是通过一个语句的md5和结果做缓存，但是一个表有更新之后相关的缓存就全部失效了。



## 2. MySQL的日志系统

MySQL的系统可以简单分为Server层和存储引擎层，而`InnoDB`使我们最常用的存储引擎。

`binlog(二进制日志)`是Server层的，而redo log(重做日志)是`InnoDB`的，`InnoDB`还有另外一个`undo log(回滚日志)`。

`redo log`是`InnoDB`特有的日志，记录在一个固定大小空间中，以循环写的方式进行，所以多久时间都不会造成日志文件过大。

`check_point`到`write_pos`是未写入磁盘的日志，`write_pos`到`check_point`是已经写入磁盘的日志。

当`write_pos`追上`check_point`的时候就需要暂停操作，先等`check_point`推进刷盘。

![](https://static001.geekbang.org/resource/image/16/a7/16a7950217b3f0f4ed02db5db59562a7.png)

上述就是`WAL（Write-Ahead Logging）`技术的核心，先写日志，在写磁盘。

如果一次更新操作中数据行并不在内存中就要先读磁盘之后更新，很浪费时间。	

`binlog`是Server层的，所有的存储引擎公用，以追加写的形式，所以时间一久可能会导致日志过多。

`binlog`可以分为两类，一类index文件，是日志的索引，记录哪些日志文件正在使用。00000x文件则是具体日志文件，记录除查询之外的语句。

`redo log`是物理日志，记录的是SQL对某条数据的修改前后的值，`binlog`是逻辑日志记录，记录执行的SQL的具体逻辑。

对于`InnoDB`来说，日志是二阶段提交的，`redo log`分为`parpre`和`commit`两种状态，因为需要和`binlog`保持一致。



## 3. MySQL事务的隔离性

### 事务简述

事务可以理解为1~N个操作的集合，集合中的操作共同具有一些的特性：(ACID Atomicity、Consistency、Isolation、Durability)原子性，一致性，隔离性，持久性

`MySQL`中事务由底层的存储引擎提供索引，`InnoDB`支持事务而`MyISAM`却不支持。

`MySQL`中可以在`information_schema`库中的`innodb_trx`表中可以查询所有正在执行的事务。





隔离性就是多个事务执行期间，相互的对对方修改内容的可见性，并发性。

因为可见性的强弱原因可能会导致:脏读，不可重复读，幻读等问题。(不可重复读和幻读我简单理解为修改和新增插入的区别)。

`InnoDB`中内置了四个隔离级别，`RU(Read Uncommitted)`,`RC(Read Committed)`,`RR(Repeatable Read)`,`Serializable`。

RU级别下面，多个事务之间不存在数据隔离，任何修改在任何事务中共享，即使没提交。

RC级别下面，多个事务之间只有提交的数据会共享。

RR级别下面，事务只能看到开启时获取到的内容，重复读并不会改变。

`Serializable`就是串行化，所有的事务串行化执行，也不存在多个事务的隔离这种东西了。

RU和`Serializable`级别下面都不需要讨论隔离性问题。

RC和RR级别下的事务隔离主要由**视图（锁和`mvcc机制`）**实现。

`MySQL中`的`mvcc机制`（多版本并发控制）主要是通过`undo log（回滚日志）`实现，对元素的修改都会在`undo log`中按顺序记录，而在事务开启时会根据自己的事务id，读取不同阶段的数据。

RC和RR级别下的`mvcc机制`会有不同的表现：

- RC级别下，每次获取到的都是当前提交的最新数据（或者说每次都会建立一个视图）。
- RR级别下，每次获取到的都是第一次Select获取的数据（只会使用第一次查询简历的视图）。



### InnoDB事务的其他特性实现

- 原子性

  通过`Undo log`实现，相当于记录下每次操作的逻辑，在发生错误或者手动rollback时撤销操作。

  在一个事务中我们能回滚对数据的操作，但是例如发送请求等操作是无法避免的，所以业务中的事务应该把会产生无法撤销的操作**尽量**放到最后。

- 持久性

  事务保证已提交的修改能安全持久的保存在系统中。

  通过`Redo log`和`Undo log`共同实现。

- 一致性

  事务在执行前后数据库的状态是一致的，狭义上来说就是保证数据的完整性约束不被打破。

  `ACID`中的持久性区别于`CAP`中的持久性，`CAP`中的持久性更多的是指分布式系统中不同系统间的数据一致性。





## 4. MySQL的索引

索引就相当于书的目录，用于提交查找效率。

`MySQL`中的索引也是在存储引擎中实现的，根据存储引擎的不同底层的数据结构可能也大相径庭。

`InnoDB`使用B+树作为底层的数据结构，而且在`InnoDB`中，数据以**索引组织表**（按照主键的顺序以索引作为数据）进行存放的，表的每一个索引都对应一棵B+树。

索引可以分为主键索引和辅助索引（非主键索引），主键索引的B+树中存放的是真实的数据，而非主键索引中存放的则时该条数据的主键。

`InnoDB`中，主键索引也可以被称为聚集索引。

在查找时，主键索引可以直接查找到数据，而辅助索引则需要通过回表，即在查找到主键之后继续扫描主键索引树。

`InnoDB`的B+树结构，所以的子节点会占据一个数据页，所以再插入删除会自然会需要一些平衡的动作，也就是`页分裂`以及`页合并`。

使用自增主键可以较好的避免在主键索引树上的`页分裂`和`页合并`的发生，以此提高插入删除的效率。

另外因为以索引作为B+树中value结构，如果索引过大也会导致整棵索引树过大，浪费内存。

`MySQL`中的索引选择遵循**最左前缀原则**，在联合的多个索引字段中，只有当查询条件为第一个索引字段的时候才能使用该索引。

另外在辅助索引树中，还有两个十分重要的规则，都是以减少回表来优化查询速度的方式：

索引覆盖：如果辅助索引的索引项包含了需要查询的数据，则不需要回表。

索引下推（index condition pushdown）：在最左前缀的基础上，以第一个索引字段做查询之后，还可以以另外的索引字段做筛选。



## 5. MySQL的全局锁和表锁

全局锁就是对整个数据库实例加锁，使数据库处于只读状态。

使用`Flushh tables with read lock`和`set global readonly=true`的效果基本一致，可以使用`unlock tables`解锁。

表级锁就是上锁对象是表的锁，`MySQL`中可以分为普通表锁和元数据锁（meta data lock，元数据是指表结构）。

显式锁表的语法是`lock tables …read/write`，和`FTWRL`一样使用`Unlock tables`解锁。

显式锁表语句也定死了事务接下来操作的对象，例如`lock tables t_test1 read`，那么之后就只能对`t_test1`进行读，写都不行，别对的表就读写都不行。

元数据锁就是锁表结构，不需要我们手动上锁，在每次增删改查之前都会自动上锁，确保操作过程中表结构的稳定。



## 6. MySQL的行锁

行锁就是对数据行记录上的锁，更细粒度的锁可以有效的提高并发效率。

二阶段锁协议：`InnoDB`的事务中锁在需要时获取，在事务结束后释放。

根据二阶段锁协议，为了提高事务的执行效率，应该把最可能造成锁冲突的操作放在最后，尽量减少锁占用的时间。

死锁就是两个操作相互等待对方资源而造成的环形等待。

`InnoDB`处理死锁有两种方法：

1. 设置最长的锁等待时间`innodb_lock_wait_timeout`
2. 启动死锁检测`innodb_deadlock_detect=on`(默认就是开启的)



## 7. mvcc的具体实现

`consisitent read view`一致性视图是`InnoDB`在实现mvcc时候采用的一种概念，描述可见的数据范围。

`start transaction with consistent snapshot`可以在开启事务的时候就创建一个视图，RC级别下无效。

`begin/start transaction`之后的第一个快照读语句才会创建视图。

读取可以分为快照读和当前读，简单区分加锁读取和更新语句之前的读取都是当前读，只会读取当前数据行，忽略mvcc。

创建的视图是基于整库的，从底层来说，新建视图会生成一个正在执行的事务数组，里面包含当前未提交的事务合集。

以数组中最小事务id为低水位，小于低水位的事务修改内容可见，以数组中最大事务id+1为高水位，高于高水位的不可见，如果在高低水位之间则判断是否处于数组之内，如果处于表示未提交不可见，不处于则可见。

`InnoDB`中的每个事务都有唯一的事务id。

例如RR级别下，事务A对一个数据行做了修改，则会在`undo log`中记录下对应改动以及事务id，如果之后事务B对其进行修改，但在事务A再次读取时，会根据事务A的事务id和`undo log`推出对应的数据。



## 8. 普通索引和唯一索引和change buffer

唯一索就是比普通索引多了个唯一键约束。

相比较来说查询方面两种索引相差不多，在找到对应的数据页（`InnoDB`中B+树的一个子节点就是一个数据页，一般为16kb，可能已经在数据页也可能需要从磁盘读取），对数据页进行二分定位后，普通索引遍历直到不满足索引条件，而唯一索引在满足之后就会退出，因为都是在内存中操作，所以性能来说相差不多。

主要在于更新，唯一索引无法使用`change buffer`，而普通索引可以。

​	`change buffer`就和`redo log`的概念差不多，如果发现需要修改的行记录所在的数据页并不在内存中，则先在`change buffer`中记录，等下次加载该数据页的时候进行`merge`。

和`redo log`相比，`redo log`是在写入时节省随机写入的时间，而`change buffer`则是在数据页不在内存中时，节省随机读取的时间。

唯一索引在更新前还需要判断唯一性约束，所以无法使用`change buffer`。



## 9. 前缀索引

11. 怎么给字符串字段加索引

字符串索引可以使用前缀索引，语句如下：

```mysql
# 使用email的前五个字符做为索引项，建立B+树
alter table t_test1 add index prefix_index_email(email(5)); 
```

相对于普通索引来说使用前缀索引所需要的空间更小，但是辨识度也低，比较操作都需要回表到主键索引。

而且使用前缀索引之后就不会触发覆盖索引机制。

对于长字符串来说也可以使用内置的hash方法`(例如crc32)`做一个比较。



## 10. 脏页问题

12. 为什么我的MySQL会抖一下

脏页就是指修改过但是未刷新到磁盘的数据页，将脏页数据同步到磁盘的操作就是刷页(flush)

MySQL基于WAL机制，写完`redo log`和内存数据页之后就返回成功，而不是非要刷新到磁盘。

flush脏页的情况有以下四种：

1. `redo log`满了，`redo log`可以看做一个固定大小的环形结构，当末尾追上开头时，就需要进行flush，将开头向前推进。
2. 内存满了，MySQL维护一个固定大小的`buffer pool`，所以当pool满了的时候就需要淘汰无用的页面，如果是脏页就需要flush。
3. 空闲，时间由MySQL决定。
4. 正常关闭

`innodb_io_capacity`用于指定刷脏页时的io量，建议设置为当前主机IOPS。

`innodb_flush_neighbors`用于指定是否连坐，开启时如果正在刷盘的脏页旁边也是脏页就会连坐一起刷。



## 11. 表空间问题

13. 为什么表数据删掉一半，表文件大小不变

对于`InnoDB`而言，一个表包括了表结构和表数据，表结构一般以`.frm文件`保存(MySQL8.0以后可以放到系统数据表中)。

`innodb_file_per_table`定义`InnoDB`中的表数据库是否以单独文件的形式保存（MySQL5.6.6之后默认为ON），ON时单独保存为`.ibd文件`。

`drop`以及`delete`相关命令并不能回收表空间，仅仅是将对应空间置为**可复用**，页分裂也会造成类似的空洞。

`alter table A engine=InnoDB`可以用来重建A表，去除空洞使数据页更加紧凑。



## 12. 行计数问题

14. count(*)这么慢，我该怎么办？

`MyISAM`会自动保存表行数，所以count取值一直O(1)的复杂度，而`InnoDB`支持mvcc，对不同的事务可能有不同的表行数，所以并没有保存。

不同的count区分，count(*),count(primary key),count(1),count(field):

首先明确count的作用：统计不为NULL的行数，count实际为聚合函数，括号内为判断是否为null的元素

- count(field)

  所以如果属性并不是`not null`，则取值之后还会判断一下是否为NULL，再累加，可能对于总行数来说会有错漏。

- count(primary key)

  会遍历整张表，但因为`primary key`不可能为空，所以省去了判断为null的环节。

- count(1)

  用1代替需要判断是否为null的字段，省去行数据解析的过程。

- count(*)

  MySQL(或者InnoDB)做了专门的优化，并不会取整行数据。



## 13. 排序相关

16. order by是怎么工作的？

`MySQL`会单独分配一块专用内存(sort buffer)给排序的需求。

排序可以分为全字段排序和`rowid`排序。

- 全字段排序：

​		根据查询字段将需要字段导入`sort buffer`，然后排序。

- `row id`排序：

  `max_length_for_sort_data`规定了导入字段的最大总长度，如果超过则会启用`row id`排序，

  将目标排序列和主键导入`sort buffer`，排序后使用主键获取完整信息。

根据`sort_buffer_size`，如果导入字段大于该值，会启用外部排序(归并排序)，部分排序后暂存在外部临时文件。

## 14. 为什么有些SQL逻辑相同，性能却差距很大

结论就是对索引字段的函数操作，会让优化器放弃走索引。

主要原因就是函数操作会破坏索引条件的有序性，如果使用索引也就是走树搜索过程，在定位到数据之后，会加载该数据页，使用节点的有序性进行二次遍历。

例如文中的t_modified索引，树中子节点是按照年月日排序的，但是调用了month()函数之后，破坏了原来的有序性，所以会直接走全表扫描的流程。

## 20. 幻读

幻读是指在同一事务中前后两次查询到的数据量不一致的情况（包括插入和删除）。

幻读的存在主要还是会破坏数据的一致性。

InnoDB在RR级别下解决了幻读问题，主要使用了Next-Key(临键锁)。

Next-key就是GAP锁加上行锁，例如表`test`中有数据id={1,3}，采用`for update`上锁时会对区间{(负无穷,1),(1,3),(3,正无穷)}上Gap锁，对1，3分别上行锁。

另外根据查询的情况，如果通过唯一索引进行精准查询且记录存在时，Next-Key就会退化为行锁，若记录不存在则退化为Gap锁。



