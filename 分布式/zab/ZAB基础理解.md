# ZAB 协议
---

[TOC]

---





## ZAB

ZAB（**Zookeeper Atomic Broadcast**  原子广播协议）包含**崩溃恢复和广播**两个子协议（或者说模式）。

广播协议保证数据的只从单节点写入而后广播到集群内所有节点，进而保证数据的顺序一致性（以及最终一致性）以及持久性（数据备份），而奔溃恢复，则是在 Leader 宕机等情况下完成新 Leader 的选举。

## ZAB 的节点角色

在广播阶段，ZAB 的节点分为以下几种角色：

- LEADER - 领导节点，负责所有的写入和 Proposal 的发起
- FOLLOWER - 跟随者节点，负责 Proposal 的写入和 ACK，可以处理读请求
- OBSERVER - 类似 FOLLOWER 但是无投票权，也不需要回复 ACK，用于增强读能力

<br>

LEADER 处于 LEADING 状态，FOLLOWER 处于 FOLLOWING 状态，而在崩溃恢复阶段还存在 LOOKING 状态，表示节点正处于投票状态。

> **LOOKING 状态下节点不对外提供读写服务。**

## ZAB 的广播（读写）模型

ZAB 的所有**写请求都必须由 LEADER 节点来处理**，如果 FOLLOWER 节点接收到写请求也会转发给 LEADER 处理。

**LEADER 节点接收到写请求后会带上 ZXID，并转化为一个 Proposal，然后将其分发给所有的 FOLLOWER 节点（包括 OBSERVER 节点）。**

ZXID 的由 Leader 生成保证其递增（应该也是连续的），这样在整个系统中可以保证事务处理的顺序性（Zookeeper 并不提供强一致性保证，只保证顺序一致性。

> ZXID 的生成：
>
> - 高 32 位是： epoch（纪元），代表着周期，每当选举产生一个新的 Leader 服务器时就会取出其本地日志中最大事务的 ZXID ，解析出 epoch（纪元）值操作加 1作为新的 epoch（相当于一个集群的逻辑时钟。
> - 低 32 位是： counter（计数器），它是一个简单的单调递增的计数器，针对客户端的每个事务请求都会进行加 1 操作；

只有在**过半**的 FOLLOWER 节点成功复制并回复 ACK 信息之后，会再次广播 COMMIT 信息表示写请求成功，最后返回写请求响应，对外可读。

> 该协议类似于 2PC，但是并不要求全部的节点都必须要写入成功。

<br>

## ZAB 的奔溃恢复（选主）流程

奔溃恢复在以下两种场景会触发：

1. 集群启动初期，首次的 Leader 选举
2. 出现网络的中断或者 Leader 节点的宕机奔溃等和 Leader 节点连接断开的情况

**在 Leader 节点和超过一半的节点建立连接并且完成数据同步之后退出奔溃恢复的状态，转而进入消息广播阶段。**

奔溃恢复阶段的保证：
 1）确保**已经在 Leader 服务器上提交（Commit）的事务最终被所有的服务器提交**。
 2）确保**丢弃那些只在 Leader 上被提出而没有被提交的事务**。

<br>

奔溃恢复的模式下，节点先进入 LOOKING 状态下，并且先给自己投票，将票以 <MyID,ZXID> 的形式计入投票箱，之后广播自己的投票信息。

各节点收到投票信息之后和本地按照如下顺序进行对比：

1. EpochId 对比
2. ZXID 进行对比
3. Sid（启动时配置的 MyID） 对比

所有对比都是大者胜出，整理投票结构之后继续进行广播。

最后判断是否有半数节点选择出 Leader，选出 Leader 后进入数据同步阶段，需要半数以上节点完成同步才能退出奔溃回复状态。





## 参考

[Zookeeper——一致性协议:Zab协议](https://www.jianshu.com/p/2bceacd60b8a)

[面试官问：ZooKeeper是强一致的吗？怎么实现的？](https://segmentfault.com/a/1190000039127403)