## Redis缓存相关



[TOC]

## 概述

缓存是现在被广泛使用的一种提高系统性能的手段（对于 GET 请求想提高性能加缓存就完事了。

相对来说数据库的承受能力较弱，如果请求全部打到数据库，那么数据库很快就会成为性能瓶颈。

查询数据库之前，先查询速度较快的缓存，可以有效减少对数据库的请求，以此达到提高系统吞吐量，性能的目的。

但是缓存如果使用不当也就会出现缓存一致性的问题。



## 缓存一致性

缓存一致性是指缓存和数据库是否相同，例如数据库已经修改但是缓存修改失败此时就会出现不一致的情况。

（以防万一，使用`redis`作为缓存时一般都会对key添加一个过期时间，就算不一致也有个期限。



## 缓存的更新策略

狭义来说就是缓存和数据库的更新机制。

一般来说，缓存可能涉及到部分额外的计算，所以**大部分情况下缓存都采取直接删除的策略**，在下一次查询的时候再拉起缓存。（懒加载策略

所以更新策略就变成了缓存先删除还是后删除的问题。（和数据库修改比较）

### 先删除缓存再修改数据库

存在问题如下：

1. 缓存在删除到数据库事务提交期间可能会被重新拉起。
2. 数据库事务回滚的时候缓存删除就是多余的



### 先修改数据库再删除缓存

缓存如果删除失败

<br>

个人遇到过最恶心的问题，由于项目中的事务管理较粗基本都是 RR 级别的 @Transaction 套住整个接口方法，所以如果两个请求并行处理的时候，A 请求先查询，B 请求在修改，但是由于 MVCC 机制，B 就算提交之后对 A 还是不可读的，后续的查询又把缓存拉起。（吐了



## 解决办法

### 1. 延时双删

具体的操作步骤如下：

1. 删除缓存
2. 更新数据库
3. 延迟一定的时间后，再删除缓存

第一次删除缓存是直接删除的旧数据，第二次删除则是保障，如果更新期间请求进来依旧会缓存旧数据，为了防止这种情况，再确保更新成功后再次删除缓存。

该方法可能会造成缓存击穿的情况。



### 2. 异步更新缓存

更新缓存和更新数据库作异步处理。

比如对于`MySQL`而言，比较常见的可以使用canal + 消息队列做异步。

canal负责解析MySQL的binlog，并将解析结果推送到消息队列(kafka,rabbitMQ等)，而后由系统接受并更新缓存。



好像上面的两种情况都会存在一段时间的不一致性，所以考虑过用 2pc 等方式做强一致性，但如果因为缓存更新失败的原因导致业务失败，好像也有点扯。





## 缓存穿透

请求中带有在数据库中都查不到的key，缓存中不存在则每次直接打到数据库进行查询。

当流量增大时可能会打爆数据库，也可能会有人特地拿不存在的来查询。

### 解决方法

1. **布隆过滤器**

   布隆过滤器可以用来判断数据库是否存在某个key，不存在则直接返回。

   但存在一定的误报率，且增加了之后可能会影响正常查询。

2. 缓存空值

   即数据库查询到空时，也保留缓存，为了容错考虑可以设置稍短一点的过期时间。



## 缓存击穿

热点key失效之后，同一时间有大量请求进来，所以就全部打到了数据库上。

缓存雪崩的情况会使数据库一下子压力陡增，严重的甚至会打爆。

### 解决办法

1. 分布式锁

   上锁之后，同一个时间只有一个请求能查库，之后的请求走缓存。

   但要注意锁的范围和粒度。

2. 永远不过期

   可以直接直接去除热点key的过期时间。



## 缓存雪崩

同一时间大量的key同时失效，导致请求直接到数据库。

### 解决办法

1. 设置不同的失效时间

   往往相同的失效时间是导致雪崩的主要原因，再极端一点可以像击穿一样缓存永远不失效。

2. 定时刷新

   部分热点key可以设置定时的刷新，保证缓存的时间充异步更新缓存足。

3. 缓存预热

   是在服务上线或者缓存重启时候的必要，避免缓存为空，导致刚开始的请求全部到数据库。







