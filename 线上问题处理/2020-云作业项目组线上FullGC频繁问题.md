## 概述

是别的项目组的问题，线上 Full GC 非常频繁导致的请求大量延时。

当场进入 pingpoint 查看，发现 Full GC 密集到看不出时间（连片的 Full GC，但是每次 Full GC 之后回收的内存空间很大，说明大量并非是长久存在的对象进入了老年代，在老年代空间不足时进行了 Full GC。

第一时间是认为参数问题，可能是进入老年代的对象大小设置错误，但是发现并没有该参数设置。

后面使用 jmap -heap 查看堆的情况，惊奇发现年轻代整个只有 10mb 左右的大小，此时就知道原因了，晋升的原因要不是频繁的 YGC，导致对象年龄暴增，或者 S1 区过小无法存放剩余对象导致直接晋升到老年代。

之后就是寻找年轻代只有 10mb 的原因，并没有配置相关参数，2G内存，也是 1:2 以及 1:1:8 的默认配置，讲道理应该有 700mb 的年轻代。

最后发现是使用的 GC处理器的问题，使用的是 Parallel Scavenge 搭配 Parallel Old 的组合，而 Parallel Scavenge 处理器包含一个参数就是  -XX:+UseAdpativeSizePolicy 会动态调整各个分区的大小以达到目标系统规定的最低相应时间或者收集频率等。

解决办法就是将我们服务的 JVM GC 配置全套抄过去。