# EventLoopGroup的初始化流程

> 以NioEventLoop为对象分析。



[TOC]

## 概述

Netty作为一种异步事件驱动的网络框架，EventLoop(事件轮询器)就是它的核心组成，是轮询并处理事件的组件。

EventLoopGroup就是EventLoop的集合，它们的关系类似于线程池和线程，绑定到EventLoopGroup相当于是绑定到Group中的某个EventLoop对象。





## 源码分析

```java
 	   		 // Configure the server.
        // doubt: EventLoop，EventLoopGroup，EventExecutor等类之间的关系
        EventLoopGroup bossGroup = new NioEventLoopGroup(1);
        EventLoopGroup workerGroup = new NioEventLoopGroup();
```

以上就是最基础的Netty服务端启动时会创建的两个EventLoopGroup。

bossGroup为前置的连接请求处理，负责监听Selector上的Accept事件，并创建Channel分派给workerGroup。

workerGroup监听Channel上的IO事件，并处理。



在EventLoopGroup初始化方法很多，以下是NioEventLoop中参数最全的构造方法了。

![image-20201019222615970](https://chenqwwq-img.oss-cn-beijing.aliyuncs.com/img/image-20201019222615970.png)

部分参数含义如下:

|          参数名          |                           参数作用                           |
| :----------------------: | :----------------------------------------------------------: |
|         nThreads         |              线程组中线程的数量，默认为CPU * 2               |
|         executor         | 事件执行器，默认为ThreadPerTaskExecutor，最终会传到SingleThreadEventExecutor |
|      chooserFactory      | 生成EventExecutorChooser的工厂，默认为DefaultEventExecutorChooserFactory |
|     selectorProvider     |          Selector的生成器，默认为原生的SPI方法返回           |
|  selectStrategyFactory   | Select选择策略的工厂，默认为DefaultSelectStrategyFactory，生成DefaultSelectStrategy |
| rejectedExecutionHandler |        线程池拒绝策略，默认为RejectedExecutionHandler        |
|     taskQueueFactory     |       任务队列工厂，用于生成EventLoop中的两个任务队列        |

EventLoopGroup本身并不会有业务逻辑的处理，基本上都是选择一个EventLoop，然后调用它的方法处理。





NioEventLoopGroup往上就是MultithreadEventLoopGroup的构造函数。

![image-20201019222746272](https://chenqwwq-img.oss-cn-beijing.aliyuncs.com/img/image-20201019222746272.png)

其中`DEFAULT_EVENT_LOOP_TRHEADS`就是默认的线程数，**Netty中定义的是当前CPU数的两倍**，两倍CPU数的线程非常适合执行IO密集型的任务，所以看到创建workerGroup时采用的默认的线程数。

![image-20201019222919297](https://chenqwwq-img.oss-cn-beijing.aliyuncs.com/img/image-20201019222919297.png)

再往上就是MultithreadEventExecutorGroup的构造函数了，吐槽一句，方法中用args来传递参数真的是可读性太差了。

```java
// MultithreadEventExecutorGroup的构造函数
protected MultithreadEventExecutorGroup(int nThreads, Executor executor,
                                            EventExecutorChooserFactory chooserFactory, Object... args) {
    	// 首先检查线程数
        if (nThreads <= 0) {
            throw new IllegalArgumentException(String.format("nThreads: %d (expected: > 0)", nThreads));
        }
         // 执行器为空的话需要新建一个
        if (executor == null) {
            // 这个执行器很特别，任何任务都会直接开一个新的线程执行
            // 这里创建的Thread其实经过包装，真实对象是FastThreadLocalThread，肯定是继承了Thread的
            // newDefaultThraedFactory就是默认的线程工厂
            executor = new ThreadPerTaskExecutor(newDefaultThreadFactory());
        }

    	// 初始化Group中的执行器数组
        // EventExecutor的数量和线程数量一致
        children = new EventExecutor[nThreads];
			// 遍历创建执行器
        for (int i = 0; i < nThreads; i++) {
            boolean success = false;
            try {
                /**
                 * 最终创建的就是NioEventLoop
                 *
                 * @see NioEventLoopGroup#newChild
                 */
                children[i] = newChild(executor, args);
                success = true;
            } catch (Exception e) {
                // 异常处理暂时忽略
            }
        }

        // 用创建的NioEventLoop，构造一个选择器
        chooser = chooserFactory.newChooser(children);
        // 声明一个监听器
        final FutureListener<Object> terminationListener = new FutureListener<Object>() {
            @Override
            public void operationComplete(Future<Object> future) throws Exception {
                // 操作是否完成
                if (terminatedChildren.incrementAndGet() == children.length) {
                    terminationFuture.setSuccess(null);
                }
            }
        };

        // 为每一个事件处理器添加监听
        // 每个EventLoop在关闭之后都会触发上面的监听器
        for (EventExecutor e : children) {
            e.terminationFuture().addListener(terminationListener);
        }

        // 为Group的所有处理器保存一份只读版本
        Set<EventExecutor> childrenSet = new LinkedHashSet<EventExecutor>(children.length);
        Collections.addAll(childrenSet, children);
        readonlyChildren = Collections.unmodifiableSet(childrenSet);
    }
```

参数中用可变长参数适配不同参数数目的调用，鉴于Netty的牛逼我就不予置评了。

整个构造函数就做了如下几件事情:

1. 创建默认的执行器。
2. 创建nThread个EventLoop。
3. 通过EventExecutorChooserFactory创建对应的EventExecutorChooser。
4. 为每个EventLoop添加关闭时的监听器。





### 创建默认的执行器

以下是ThreadPerTaskExecutor的全部代码。

![image-20201019223907388](https://chenqwwq-img.oss-cn-beijing.aliyuncs.com/img/image-20201019223907388.png)

这个执行器的功能，简单来说就是每来一个任务就通过ThreadFatcory开启一个新的线程去执行。

再来看ThreadFactory的部分，以下是`DefaultThreadFactory`创建新线程的方法。

![image-20201019223644097](https://chenqwwq-img.oss-cn-beijing.aliyuncs.com/img/image-20201019223644097.png)

Netty中对Thread和Runnable也做了进一步的包装，采用了自定义的FastThreadLocalThread和FastThreadLocalRunnable。

FastThreadLocalThread和FastThreadLocalRunnable都是Netty的FastThreadLocal系列工具类中不可少的一部分。

EventLoopGroup中创建的Executor会被所有的EventLoop共享，也就是说NioEventLoopGroup中所有NioEventLoop绑定的线程都是FastThreadLocalThread。



### * 创建EventLoop

该部分是非常重要的逻辑，包含了EventLoop中初始化的流程和其中一些继承关系。

以下是NioEventLoop#newChild的方法逻辑。

![image-20201019224315626](https://chenqwwq-img.oss-cn-beijing.aliyuncs.com/img/image-20201019224315626.png)

简单来说就是创建NioEventLoop的基本对象，但是用到了一些调用EventLoopGroup构造函数时传递的参数,通过该死的args传递。

![image-20201019230708750](https://chenqwwq-img.oss-cn-beijing.aliyuncs.com/img/image-20201019230708750.png)

以上是NioEventLoop部分的构造函数，**主要是就是通过SelectorProvider创建一个新的Selector选择器。**

NioEventLoop往上的部分，会将通过`newTaskQueue(queueFactory)`创建的队列用于`tailTasks`以及`taskQueue`的初始化。

以下是SingleThreadEventLoop的构造函数，通过传递过来的参数初始化tailTasks。

![image-20201126235626665](https://chenqwwq-img.oss-cn-beijing.aliyuncs.com/img/image-20201126235626665.png)

**tailTasks可以称为低优先级队列，因为它实在轮询周期最后才执行的，但是里面的任务都会被执行完毕。**

以下是SingleThreadEventExecutor的构造函数:

![image-20201126235713997](https://chenqwwq-img.oss-cn-beijing.aliyuncs.com/img/image-20201126235713997.png)

**此处完成了taskQueue的初始化，它是常规的任务队列，在轮询周期中会有一定的事件来执行其内的任务。**

addTaskWakesUp默认为false，暂时不知道具体作用，此时线程并没有启动。

另外值得关注的就是ThreadExecutorMap类的调用。

![image-20201127000235931](https://chenqwwq-img.oss-cn-beijing.aliyuncs.com/img/image-20201127000235931.png)

对executor的调用进行了一次包装，包装中替换Runnable方法，在Runnable方法执行前后会分别调用两个方法，以下是调用的两个方法源码：

![image-20201127000602305](https://chenqwwq-img.oss-cn-beijing.aliyuncs.com/img/image-20201127000602305.png)

这两个方法的作用和就是操作线程的本地缓存，将NioEventLoop对象放入线程本地的FastThreadLocalMap缓存。

设置了之后就可以通过`ThreadExecutorMap.currentExecutor`获取当前线程对应的NioEventLoop，这是从FastThreadLocalThread层面的关系绑定。



从SingleThreadEventExecutor再往上调用就是AbstractScheduledEventExecutor的了，该类的构造函数比较简单，但是该类包含另外一个队列。

![image-20201127002758835](https://chenqwwq-img.oss-cn-beijing.aliyuncs.com/img/image-20201127002758835.png)

**如上图所示就是优先级队列，里面保存的是定时任务，**轮询周期中会将到期的任务添加到taskQueue的末尾。

以deadline为排序规则，即将到期的任务会在优先级队列的顶部，这个PriorityQueue也是Netty自己实现的DefaultPriorityQueue。

![image-20201127003258517](https://chenqwwq-img.oss-cn-beijing.aliyuncs.com/img/image-20201127003258517.png)



在往上到了AbstractEventExecutor，终于完成了对parent参数的初始化:

![image-20201127003443025](https://chenqwwq-img.oss-cn-beijing.aliyuncs.com/img/image-20201127003443025.png)



通过以上的构造函数调用流程可以勉强分析出NioEventLoop的整体结构:

首先是三个任务队列:

1. scheduledTaskQueue - DefaultPriorityQueue类型，用于定时任务
2. taskQueue -  mpsc型队列，用于常规任务
3. tailTasks - mpsc型队列，用于低优先任务保存



另外最重要的，**NioEventLoop会持有一个Seletor对象。**





### 创建EventExecutorChooser

以下是DefaultEventExecutorChooserFactory的newChooser方法源码。

![image-20201019232145341](https://chenqwwq-img.oss-cn-beijing.aliyuncs.com/img/image-20201019232145341.png)

**通过事务执行器的线程个数是否为二次方判断使用哪种Chooser。**

以下分别是两种Chooser的方法，PowerOfTwoEventExecutorChooser的如下:

![image-20201019232346486](https://chenqwwq-img.oss-cn-beijing.aliyuncs.com/img/image-20201019232346486.png)

GenericEventExecutorChooser的如下:

![image-20201019232445792](https://chenqwwq-img.oss-cn-beijing.aliyuncs.com/img/image-20201019232445792.png)

比较之下，PowerOfTwoEventExecutorChooser就是在线程数为2次方的时候作的细微优化，采用&取代%，位操作能提升一些代码性能，类似于HashMap中的选址方式。

另外还有意思的是这个方法，判断一个数是否是二次方:

![image-20201019232710692](https://chenqwwq-img.oss-cn-beijing.aliyuncs.com/img/image-20201019232710692.png)



