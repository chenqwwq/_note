# 客户端Channel的建立过程

> 客户端连接之后的Channel对象创建和初始化过程。

[TOC]

## 概述

根据Reactor模型论述，接受连接创建Channel的工作就是由前端的BossGroup来完成的。

从NioServerSocketChannel的accpet返回的Java原生Channel如何包装为Netty中的NIoSocketChannel，就是今天所要分析的内容。



以原生的Nio网络模型来看，就是处理ServerSocketChannel的OP_ACCPET事件。

经过之前的流程，NioServerSocketChannel已经绑定到BossGroup的EventLoop中，也就是说生成NIoSocketChannel的起点就在EventLoop的时间轮询方法中。

![](https://chenqwwq-img.oss-cn-beijing.aliyuncs.com/img/image-20201122230741489.png)

以上就是NioEventLoop#run方法中的一段，这里就包含了SelectionKey.OP_ACCEPT事件的处理。

一切的开始就是从Unsafe#read方法开始的。



## 一、获取并包装原生的Channel

以下就是AbstractNioMessageChannel$NioMessageUnsafe#read方法的部分源码:

Unsafe的实现分为NioMessageUnsafe以及NioByteUnsafe，不同的是NioByteUnsafe只处理以ByteBuf为目标的读取，而NioMessageUnsafe读取所有对象。

![](https://chenqwwq-img.oss-cn-beijing.aliyuncs.com/img/image-20201122231328166.png)

首先是通过doReadMessages方法，读取所有数据到readBuf中，readBuf是一个`List<Object>`对象，作为缓存。

![image-20201122231444241](https://chenqwwq-img.oss-cn-beijing.aliyuncs.com/img/image-20201122231444241.png)

AbstractNioMessageChannel#doReadMessages是一个模板方法，具体的实现在NioServerSocketChannel中。

![image-20201122231704714](https://chenqwwq-img.oss-cn-beijing.aliyuncs.com/img/image-20201122231704714.png)

这里会先调用accept的方法获取一个原生的SocketChannel对象，然后还直接以new的方式，将其作为参数包装成NioSocketChannel，添加到buf中。

如果此次没有读取到数据，就直接跳出do...while循环了。

另外控制循环的allocHandle.continueReading方法就暂时不考虑了，**此时readBuf中就保存了所有就绪的NioSocketChannel。**



之后就是遍历处理这些获取到的Channel对象了，通过触发一个channelRead事件，将读取到的Channel传播出去，最后触发channelReadComplete事件。





## 二、 传播channelRead事件

在第一步中，原生的Channel通过事件传播机制，来到了ChannelPipeline中。

![image-20201122233303967](https://chenqwwq-img.oss-cn-beijing.aliyuncs.com/img/image-20201122233303967.png)

因为是channelRead事件，首先就到了HeadConetxt中，但是HeadContext并没有处理，而是直接往后传播，如果没有指定别的ChannelHandler，之后就到了`ServerBootstrapAcceptor`中。

`ServerBootstrapAcceptor`这个类就是在最开始创建服务端Channel并初始化的过程中指定的。

以下是ServerBootstrap#init方法:

![image-20201122233545450](https://chenqwwq-img.oss-cn-beijing.aliyuncs.com/img/image-20201122233545450.png)

可以看上图稍微回顾一下之前的流程。

以下就是ServerBootstrap$ServerBootstrapAcceptor#channelRead的源码:

![image-20201122233715818](https://chenqwwq-img.oss-cn-beijing.aliyuncs.com/img/image-20201122233715818.png)

上来显示相似的三种配置:

1. 配置ChannelPipeline
2. 配置ChannelOptions
3. 配置Attributes

以上三种都是在ServerBootstrap时就指定的。

最后是走的注册方法，将初始化完毕的NioSocketChannel注册到workerGroup中(图片中的childGroup)。

注册的逻辑和服务端Channel的注册基本没什么不同，都是异步的。



到这里就开启





## 总结

整个添加的流程如下:

1. 通过accpet方法获取JDK原生Channel
2. 初始化Channel，包括ChannelPipeline，ChannelOptions以及Attribute
3. 注册到workerGroup，开启读取。



因为Netty对Channel的重新封装比较好，NioServerSocketChannel和NioSocketChannel的方法和表现基本一致，包括注册的方法。

不同的是，NioServerSocketChannel在创建的时候指定的readInterectOp是OP_ACCEPT类型，而NioSocketChannel的是OP_READ类型。

![image-20201122235158546](https://chenqwwq-img.oss-cn-beijing.aliyuncs.com/img/image-20201122235158546.png)

AbstractNioByteChannel是NioSocketChannel的直接父类。

![image-20201122235227811](https://chenqwwq-img.oss-cn-beijing.aliyuncs.com/img/image-20201122235227811.png)