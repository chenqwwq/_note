# EventLoop对事件的响应

> 以NioEventLoop为例子，分析EventLoop对Channel事件的处理流程。
>



## 概述

在之前的初始化流程中，我们创建了服务端的NioServerSocketChannel，然后将其绑定在EventLoop上，也就相当于绑定在EventLoop持有的Selector上。

并且为每个Channel创建了各自的ChannelPipeline用于存储自定义的处理逻辑的管道。

作为以上准备之后就开始对Selector进行监听并且处理其上的IO事件了。





## EventLoop的结构

EventLoop就是Netty中的轮询器，它持有JDK原生的Selector的引用，并且负责其上就绪的所有IO事件。

NioEventLoop继承了SingleThreadEventLoop类，所以明显的它就是**单线程结构**。

另外NioEventLoop中存在四种任务类型:

1. 定时任务，这个是在AbstractScheduledEventExecutor中提供的
2. 正常任务，这是SingleThreadEventExecutor中提供的
3. 低优先级任务，这是SingleThreadEventLoop中提供的
4. Selector触发的IO事件



Nio的轮询逻辑不仅仅包含了Selector的IO事件的处理，还有以上三级任务的处理。

## EventLoop什么时候开启轮询

最终NioEventLoop的run方法最终发现**NioEventLoop采用的是懒开始的策略，只有在执行第一次任务的时候才会开启线程**。

以下是EventLoop实现的几种execute方法:

![image-20201116230458199](https://chenqwwq-img.oss-cn-beijing.aliyuncs.com/img/image-20201116230458199.png)

在最后一个executor方法中，会先调用addTask添加任务到taskQueue。

并且判断EventLoop事都是当前线程，如果不是当前线程则会调用startThread方法开启线程，因为startThread方法会多次被调用，但是线程不能被多次开启，所以方法内部应该是会有相应的判断限制。

![image-20201116230731561](https://chenqwwq-img.oss-cn-beijing.aliyuncs.com/img/image-20201116230731561.png)

好像是的，只有EventLoop的状态为ST_NOT_STARTED的时候才会替换状态为ST_STARTED，然后继续进一步线程启动调用。

doStartThread方法很长，这里直接去catch之前的部分。

![image-20201116230956636](https://chenqwwq-img.oss-cn-beijing.aliyuncs.com/img/image-20201116230956636.png)

就是直接调用的当前类的run方法，调用的形式是`SingleThreadEventExecutor.this.run()s`。



确定了EventLoop是在第一次调用executor方法的时候开启的线程，那么什么时候会首先调用executor方法呢?

对于NioEventLoop来说，第一次调用executor的地方就是注册的时候。

在创建了EventLoopGroup的时候就已经定义了n个EventLoop对象，并且以数组形式存放，但是此时并没有开启事件轮询，线程并没有开启。

在有Channel注册进来之后才开始轮询，但此时Channel可能并没有注册到Selector，甚至Channel都没有绑定到本地端口。

以下代码是AbstractChannel$AbstractUnsafe#register方法的节选:

![image-20201116232252233](https://chenqwwq-img.oss-cn-beijing.aliyuncs.com/img/image-20201116232252233.png)

在判断当前线程并不是希望注册到的EventLoop中的线程时，会直接调用eventLoop.executor方法，也就开启了线程的轮询方法。

## EventLoop的轮询逻辑

NioEventLoop的轮询逻辑就在run方法里，其内部源码如下:

```java
  @Override
    protected void run() {
        int selectCnt = 0;
        for (; ; ) {
            try {
                int strategy;
                try {
                    /** {@link io.netty.channel.DefaultSelectStrategy} **/
                    // 如果有任务会返回selectNow的值，如果灭有返回SelectStrategy.SELECT
                    // selectNowSupplier是直接实现的selectNow
                    strategy = selectStrategy.calculateStrategy(selectNowSupplier, hasTasks());
                    // 如果hashTasks为ture,调用的selectNow方法，就会跳过switch。
                    switch (strategy) {
                        case SelectStrategy.CONTINUE:
                            continue;
                        case SelectStrategy.BUSY_WAIT:
                            // fall-through to SELECT since the busy-wait is not supported with NIO
                        case SelectStrategy.SELECT:
                            // 进到这部分代码说明任务队列为空 ===> hasTasks() return false
                            /*
                             * tailTasks和taskQueue都为空
                             *
                             * 至于为什么需要两个队列的原因，是因为SingleThreadEventLoop在SingleThreadEventExecutor的基础上进行的扩展
                             * tailTasks为低优先级队列，只有在taskQueue的任务执行完之后才会被执行
                             *
                             * SingleThreadEventLoop持有tailTasks，保存所有低优先级任务
                             * SingleThreadEventExecutor持有taskQueue，保存所有正常的任务队列
                             * AbstractScheduledEventExecutor持有scheduledTaskQueue，保存所有延时任务
                             **/

                            // 这里是计算需要等待的时间
                            // 找到队列中下一个计划好的时间,直接从优先级队列中查看队首的任务
                            /**
                             * @see AbstractScheduledEventExecutor
                             */
                            long curDeadlineNanos = nextScheduledTaskDeadlineNanos();
                            if (curDeadlineNanos == -1L) {
                                curDeadlineNanos = NONE; // nothing on the calendar
                            }
                            nextWakeupNanos.set(curDeadlineNanos);
                            try {
                                // 没有任务的话就调用select阻塞当前线程，等待IO事件
                                if (!hasTasks()) {
                                    strategy = select(curDeadlineNanos);
                                }
                            } finally {
                                // This update is just to help block unnecessary selector wakeups
                                // so use of lazySet is ok (no race condition)
                                nextWakeupNanos.lazySet(AWAKE);
                            }
                            // fall through
                        default:
                    }
                } catch (IOException e) {
                    // If we receive an IOException here its because the Selector is messed up. Let's rebuild
                    // the selector and retry. https://github.com/netty/netty/issues/8566
                    
                    rebuildSelector0();
                    selectCnt = 0;
                    handleLoopException(e);
                    continue;
                }
                
    								// 到这里，strategy就肯定带了select的结果
                // 1. 没有任务，会调用阻塞的select方法
                // 2. 有任务，会直接调用selectNow方法
                
                selectCnt++;
                cancelledKeys = 0;
                needsToSelectAgain = false;
                final int ioRatio = this.ioRatio;
                boolean ranTasks;
                // ioRatio好像是io事件处理的比例吧
                // 每个分支里都会调用runAllTasks的方法
                if (ioRatio == 100) {
                    try {
                        if (strategy > 0) {
                            // 处理IO请求
                            processSelectedKeys();
                        }
                    } finally {
                        // Ensure we always run tasks.
                        // 执行所有的任务
                        ranTasks = runAllTasks();
                    }
                } else if (strategy > 0) {
                    final long ioStartTime = System.nanoTime();
                    try {
                        processSelectedKeys();
                    } finally {
                        // Ensure we always run tasks.
                        final long ioTime = System.nanoTime() - ioStartTime;
                        ranTasks = runAllTasks(ioTime * (100 - ioRatio) / ioRatio);
                    }
                } else {
                    ranTasks = runAllTasks(0); // This will run the minimum number of tasks
                }

                if (ranTasks || strategy > 0) {
                    if (selectCnt > MIN_PREMATURE_SELECTOR_RETURNS && logger.isDebugEnabled()) {
                        logger.debug("Selector.select() returned prematurely {} times in a row for Selector {}.",
                                selectCnt - 1, selector);
                    }
                    selectCnt = 0;
                } else if (unexpectedSelectorWakeup(selectCnt)) { // Unexpected wakeup (unusual case)
                    selectCnt = 0;
                }
            } catch (CancelledKeyException e) {
                // Harmless exception - log anyway
                if (logger.isDebugEnabled()) {
                    logger.debug(CancelledKeyException.class.getSimpleName() + " raised by a Selector {} - JDK bug?",
                            selector, e);
                }
            } catch (Throwable t) {
                handleLoopException(t);
            }
            // Always handle shutdown even if the loop processing threw an exception.
            try {
                if (isShuttingDown()) {
                    closeAll();
                    if (confirmShutdown()) {
                        return;
                    }
                }
            } catch (Throwable t) {
                handleLoopException(t);
            }
        }
    }
```



### 1. 获取IO就绪事件

第一步就是通过selectStrategy获取需要需要执行的任务。

以下是DefaultSelectStrategty的所有源码:

![image-20201116234430287](https://chenqwwq-img.oss-cn-beijing.aliyuncs.com/img/image-20201116234430287.png)

首先方法的第二个参数就是hasTask的返回值。

也就是说**有需要执行的任务时就直接调用get方法获取Selector上就绪的IO事件。**

需要注意的是这里的get方法不是阻塞的，SelectSupplier的实现如下:

![image-20201117002547364](https://chenqwwq-img.oss-cn-beijing.aliyuncs.com/img/image-20201117002547364.png)

selectNow就不放源码了，就是`selector.selectNow()`。

如果没有任务的话返回的会是SelectStrategt.SELECT，这里先看一下相关的常量的定义:

![image-20201117003114805](https://chenqwwq-img.oss-cn-beijing.aliyuncs.com/img/image-20201117003114805.png)

因为selector.selectNow最小返回也是0，所以如果存在任务的话，就不会进入switch的判断了。

如果没有存在任务的话，会进入switch的SELECT分支，**该分支会计算下一次延时任务的时间，然后调用阻塞的select方法，阻塞对应时间来等待Selector对象上的事件就绪**。

所以在当代码执行到switch以下时，肯定以及获取过一遍就绪的IO事件，可能为0。

1. 存在任务，直接调用selectNow。
2. 没有任务，调用select方法，阻塞到下一次定时任务。



在分析下面两步之前，还可以再讲讲ioRatio的作用。

这个参数好像只能通过Set方法去设置，它决定了IO事件所占的比例，runAllTasks方法是以执行的总时间

### 2. 执行就绪的IO事件

![image-20201117071311950](https://chenqwwq-img.oss-cn-beijing.aliyuncs.com/img/image-20201117071311950.png)

### 3. 执行所有任务

执行所有任务的方法分为两种，带超时时间和不带超时时间的。

先来看不带超时时间的:

![image-20201117072056927](https://chenqwwq-img.oss-cn-beijing.aliyuncs.com/img/image-20201117072056927.png)

方法中先通过的fetchFromScheduledTaskQueue获取到定时的任务。

![image-20201117072655754](https://chenqwwq-img.oss-cn-beijing.aliyuncs.com/img/image-20201117072655754.png)

该方法的逻辑看上去好像很简单，就是从定时队伍的队列中获取Runnable形式的任务，然后将任务添加到taskQueue，如果失败再加回到scheduledTaskQueue。