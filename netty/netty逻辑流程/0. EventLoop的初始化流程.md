# EventLoopGroup的初始化流程

> 以NioEventLoopGroup为对象分析。



[TOC]

## EventLoopGroup概述

EventLoopGroup 就是 EventLoop 的集合，是 Netty 中异步以及事件处理实现的基本组件。

Netty 中可以定义两个不同作用的 EventLoopGroup，分别对应的 Reactor 模型中的前端接收线程组以及后端事件处理线程组。

```java
EventLoopGroup bossGroup = new NioEventLoopGroup(1);
EventLoopGroup workerGroup = new NioEventLoopGroup();
try {
    // 创建并配置SeverBootStrap
    // 构造函数啥事没干
    ServerBootstrap b = new ServerBootstrap();
    // 指定两个线程组,Netty是以何种Reactor的形式运行的在此时就决定了
    b.group(bossGroup, workerGroup)
```

以上就是 Netty 服务端启动时都会创建并指定的两个线程组。

bossGroup 就是接收线程组Acceptors，负责监听 Selector 上的 Accept 事件，并创建 Channel 分派给 workerGroup，往往是单线程。

workerGroup 也就是事件处理线程组，在多线程情况下，每个线程会绑定一个 Selector，并且使用 Selector 监听所有注册的SocketChannel 的 IO 事件，读取数据，分发到 Pipeline 中处理，并回写。

 

### NioEventLoopGroup初始化流程

#### NioEventLoopGroup

以 NioEventLoopGroup 为例，逐步分析，以下是 NioEventLoopGroup 中参数最全的构造方法了。

![image-20201019222615970](https://chenqwwq-img.oss-cn-beijing.aliyuncs.com/img/image-20201019222615970.png)

部分参数含义如下:

|          参数名          |                           参数作用                           |
| :----------------------: | :----------------------------------------------------------: |
|         nThreads         |    线程组中线程的数量，在NioEventLoopGroup中默认为CPU * 2    |
|         executor         | 事件执行器，默认为ThreadPerTaskExecutor，最终会传到SingleThreadEventExecutor |
|      chooserFactory      | 生成EventExecutorChooser的工厂，默认为DefaultEventExecutorChooserFactory |
|     selectorProvider     |          Selector的生成器，默认为原生的SPI方法返回           |
|  selectStrategyFactory   | Select选择策略的工厂，默认为DefaultSelectStrategyFactory，生成DefaultSelectStrategy |
| rejectedExecutionHandler |        线程池拒绝策略，默认为RejectedExecutionHandler        |
|     taskQueueFactory     |       任务队列工厂，用于生成EventLoop中的两个任务队列        |

**EventLoopGroup 本身并不会有业务逻辑的处理，基本上都是选择一个 EventLoop，然后调用它的方法处理。**



#### MultithreadEventLoopGroup

NioEventLoopGroup 往上就是 MultithreadEventLoopGroup 的构造函数。

![image-20201019222746272](https://chenqwwq-img.oss-cn-beijing.aliyuncs.com/img/image-20201019222746272.png)

其中 DEFAULT_EVENT_LOOP_TRHEADS 就是默认的线程数，**Netty 中定义的是当前CPU数的两倍**，两倍CPU数的线程非常适合执行IO密集型的任务，所以看到创建 workerGroup 时采用的默认的线程数。

![image-20201019222919297](https://chenqwwq-img.oss-cn-beijing.aliyuncs.com/img/image-20201019222919297.png)

#### MultithreadEventExecutorGroup

再往上就是 MultithreadEventExecutorGroup 的构造函数，

```java
// MultithreadEventExecutorGroup的构造函数
protected MultithreadEventExecutorGroup(int nThreads, Executor executor,
                                            EventExecutorChooserFactory chooserFactory, Object... args) {
    		// 首先检查线程数
        if (nThreads <= 0) {
            throw new IllegalArgumentException(String.format("nThreads: %d (expected: > 0)", nThreads));
        }
         // 执行器为空的话需要新建一个
        if (executor == null) {
            // 这个执行器很特别，任何任务都会直接开一个新的线程执行
            // 这里创建的Thread其实经过包装，真实对象是FastThreadLocalThread，肯定是继承了Thread的
            // newDefaultThraedFactory就是默认的线程工厂
            executor = new ThreadPerTaskExecutor(newDefaultThreadFactory());
        }
		// 初始化Group中的执行器数组
        // EventExecutor的数量和线程数量一致
        children = new EventExecutor[nThreads];
        // 遍历创建执行器
        for (int i = 0; i < nThreads; i++) {
            boolean success = false;
            try {
                /**
                 * 最终创建的就是NioEventLoop
                 *
                 * @see NioEventLoopGroup#newChild
                 */
                children[i] = newChild(executor, args);
                success = true;
            } catch (Exception e) {
                // 异常处理暂时忽略
            }
        }

        // 用创建的NioEventLoop，构造一个选择器
        chooser = chooserFactory.newChooser(children);
        // 声明一个监听器
        final FutureListener<Object> terminationListener = new FutureListener<Object>() {
            @Override
            public void operationComplete(Future<Object> future) throws Exception {
                // 操作是否完成
                if (terminatedChildren.incrementAndGet() == children.length) {
                    terminationFuture.setSuccess(null);
                }
            }
        };

        // 为每一个事件处理器添加监听
        // 每个EventLoop在关闭之后都会触发上面的监听器
        for (EventExecutor e : children) {
            e.terminationFuture().addListener(terminationListener);
        }

        // 为Group的所有处理器保存一份只读版本
        Set<EventExecutor> childrenSet = new LinkedHashSet<EventExecutor>(children.length);
        Collections.addAll(childrenSet, children);
        readonlyChildren = Collections.unmodifiableSet(childrenSet);
    }
```

参数中用可变长参数适配不同参数数目的调用，鉴于Netty的牛逼我就不予置评了。

整个构造函数就做了如下几件事情:

1. 创建默认的执行器。
2. 创建nThread个EventLoop。
3. 通过EventExecutorChooserFactory创建对应的EventExecutorChooser。
4. 为每个EventLoop添加关闭时的监听器。



整个NioEventLoopGroup的构造函数调用链下来，主要的还是最后NioEventLoop的创建，另外还有一些相关的工具类的创建，比如选择器。

**选择器就是NioEventLoopGroup用来挑选工作线程的工具类，由其持有所有的NioEventLoop成员。**

在accept事件中，创建的SocketChannel后会通过选择器挑选一个NioEventLoop，并将SocketChannel绑定到其上的Selector。



### 选择器 - EventExecutorChooser

以下是DefaultEventExecutorChooserFactory的newChooser方法源码。

![image-20201019232145341](https://chenqwwq-img.oss-cn-beijing.aliyuncs.com/img/image-20201019232145341.png)

**通过事务执行器的线程个数是否为二次方判断使用哪种Chooser。**

以下分别是两种Chooser的方法，PowerOfTwoEventExecutorChooser的如下:

![image-20201019232346486](https://chenqwwq-img.oss-cn-beijing.aliyuncs.com/img/image-20201019232346486.png)

GenericEventExecutorChooser的如下:

![image-20201019232445792](https://chenqwwq-img.oss-cn-beijing.aliyuncs.com/img/image-20201019232445792.png)

比较之下，PowerOfTwoEventExecutorChooser就是在线程数为2次方的时候作的细微优化，采用&取代%，位操作能提升一些代码性能，类似于HashMap中的选址方式。

**但总的来说都还是轮询的方式，Group中每个EventLoop都会均匀的得到任务或者Channel。**

另外还有意思的是这个方法，判断一个数是否是二次方:

![image-20201019232710692](https://chenqwwq-img.oss-cn-beijing.aliyuncs.com/img/image-20201019232710692.png)



### 默认的执行器 - ThreadPerTaskExecutor

以下是ThreadPerTaskExecutor的全部代码。

![image-20201019223907388](https://chenqwwq-img.oss-cn-beijing.aliyuncs.com/img/image-20201019223907388.png)

这个执行器的功能，简单来说**就是每来一个任务就通过ThreadFatcory开启一个新的线程去执行。**

再来看ThreadFactory的部分，以下是`DefaultThreadFactory`创建新线程的方法。

![image-20201019223644097](https://chenqwwq-img.oss-cn-beijing.aliyuncs.com/img/image-20201019223644097.png)

**Netty中对Thread和Runnable也做了进一步的包装，采用了自定义的FastThreadLocalThread和FastThreadLocalRunnable。**

FastThreadLocalThread和FastThreadLocalRunnable都是Netty的FastThreadLocal系列工具类中不可少的一部分。

EventLoopGroup中创建的Executor会被所有的EventLoop共享，也就是说NioEventLoopGroup中所有NioEventLoop绑定的线程都是FastThreadLocalThread。 



### NioEventLoop的初始化

这是上一部分中最重要的逻辑了，就是Group中成员NioEventLoop的初始化，初始化的开头还是从NioEventLoopGroup实现的模板方法中开始的。

以下是NioEventLoop#newChild的方法逻辑。

![image-20201019224315626](https://chenqwwq-img.oss-cn-beijing.aliyuncs.com/img/image-20201019224315626.png)

简单来说就是创建NioEventLoop的基本对象，但是用到了一些调用EventLoopGroup构造函数时传递的参数,通过该死的args传递。

![image-20201019230708750](https://chenqwwq-img.oss-cn-beijing.aliyuncs.com/img/image-20201019230708750.png)

以上是NioEventLoop部分的构造函数，**主要是就是通过SelectorProvider创建一个新的Selector选择器。**

NioEventLoop往上的部分，会将通过`newTaskQueue(queueFactory)`创建的队列用于`tailTasks`以及`taskQueue`的初始化。

以下是SingleThreadEventLoop的构造函数，通过传递过来的参数初始化tailTasks。

![image-20201126235626665](https://chenqwwq-img.oss-cn-beijing.aliyuncs.com/img/image-20201126235626665.png)

**tailTasks可以称为低优先级队列，因为它实在轮询周期最后才执行的，但是里面的任务都会被执行完毕。**

以下是SingleThreadEventExecutor的构造函数:

![image-20201126235713997](https://chenqwwq-img.oss-cn-beijing.aliyuncs.com/img/image-20201126235713997.png)

**此处完成了taskQueue的初始化，它是常规的任务队列，在轮询周期中会有一定的事件来执行其内的任务。**

addTaskWakesUp默认为false，暂时不知道具体作用，此时线程并没有启动。

另外值得关注的就是ThreadExecutorMap类的调用。

![image-20201127000235931](https://chenqwwq-img.oss-cn-beijing.aliyuncs.com/img/image-20201127000235931.png)

对executor的调用进行了一次包装，包装中替换Runnable方法，在Runnable方法执行前后会分别调用两个方法，以下是调用的两个方法源码：

![image-20201127000602305](https://chenqwwq-img.oss-cn-beijing.aliyuncs.com/img/image-20201127000602305.png)

这两个方法的作用和就是操作线程的本地缓存，将NioEventLoop对象放入线程本地的FastThreadLocalMap缓存。

设置了之后就可以通过`ThreadExecutorMap.currentExecutor`获取当前线程对应的NioEventLoop，这是从FastThreadLocalThread层面的关系绑定。



从SingleThreadEventExecutor再往上调用就是AbstractScheduledEventExecutor的了，该类的构造函数比较简单，但是该类包含另外一个队列。

![image-20201127002758835](https://chenqwwq-img.oss-cn-beijing.aliyuncs.com/img/image-20201127002758835.png)

**如上图所示就是优先级队列，里面保存的是定时任务，**轮询周期中会将到期的任务添加到taskQueue的末尾。

以deadline为排序规则，即将到期的任务会在优先级队列的顶部，这个PriorityQueue也是Netty自己实现的DefaultPriorityQueue。

![image-20201127003258517](https://chenqwwq-img.oss-cn-beijing.aliyuncs.com/img/image-20201127003258517.png)



在往上到了AbstractEventExecutor，终于完成了对parent参数的初始化:

![image-20201127003443025](https://chenqwwq-img.oss-cn-beijing.aliyuncs.com/img/image-20201127003443025.png)



通过以上的构造函数调用流程可以勉强分析出NioEventLoop的整体结构:

首先是三个任务队列:

1. scheduledTaskQueue - DefaultPriorityQueue类型，用于定时任务
2. taskQueue -  mpsc型队列，用于常规任务
3. tailTasks - mpsc型队列，用于低优先任务保存



另外最重要的，**NioEventLoop会持有一个Seletor对象。**







### 总结

从初始化流程中可以明确的之后以下几点内容：

> NioEventLoopGroup不处理任何业务逻辑

NioEventLoopGroup的初始化过程中并不包含Selector的存在，所以它并没有直接和网络打交道的能力。

更抽象的来说，Grouo更像是一个调度中心，所有的逻辑通过Chooser选择一个EventLoop然后委托执行。



> 在NioEventLoopGroup中任务的分派规则

因为是通过Chooser的分派，所以看两种Chooser的源码很容易能看出来总体来说还是通过轮询的形式来的。

每一个EventLoop都会获得均匀的任务。



> Runnable以及Thread在Netty中的进一步包装

Netty并没有直接使用Runnable和Thread对象，而是采用了FastThreadLocalRunnable以及FastThreadLocalThread。

这两种对象和FastThreadLocal是成体系的，FastThreadLocalThread保存类似于ThreadLocalMap一样的线程私有数据，而FastThreadLocalRunnable保证在任务完成之后对无用数据的清理，<font size=2>(虽然这种清理并不干净)</font>。



> 通过NioEventLoop的初始化，可以大概的看出其结构

NioEventLoop其内只绑定了单个的线程，并从不同维度提供了三种任务添加执行机制。



另外还有一点就是，在EventLoopGroup初始化完成之后，Selector已经创建，但是线程并没有开启。