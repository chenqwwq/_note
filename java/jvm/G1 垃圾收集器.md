# G1 垃圾收集器

> 说是整理基本就是白嫖 R大 的整理。





## G1 的 GC模式

> G1 收集器的 GC 默认可以分为：**Young GC 以及 Mixed GC**。

[R大的解释](https://hllvm-group.iteye.com/group/topic/44381)

Young GC 就是对 Young 区的 GC，而 Mided GC 是在 Young GC 的基础上加上收益较高的 Old 区。

从最高层看，G1的collector一侧其实就是两个大部分：
\* 全局并发标记（global concurrent marking）
\* 拷贝存活对象（evacuation）
而这两部分可以相对独立的执行。

Global concurrent marking 基于SATB形式的并发标记。它具体分为下面几个阶段：
1、**初始标记（initial marking）**：暂停阶段。扫描根集合，标记所有从根集合可直接到达的对象并将它们的字段压入扫描栈（marking stack）中等到后续扫描。G1 使用外部的 bitmap 来记录 mark信息，而不使用对象头的 mark word 里的 mark bit。在分代式G1模式中，初始标记阶段借用 young GC 的暂停，因而没有额外的、单独的暂停阶段。
2、**并发标记（concurrent marking）**：并发阶段。不断从扫描栈取出引用递归扫描整个堆里的对象图。每扫描到一个对象就会对其标记，并将其字段压入扫描栈。重复扫描过程直到扫描栈清空。过程中还会扫描SATB write barrier所记录下的引用。
3、**最终标记（final marking，在实现中也叫 remarking ）**：暂停阶段。在完成并发标记后，每个Java线程还会有一些剩下的SATB write barrier记录的引用尚未处理。这个阶段就负责把剩下的引用处理完。同时这个阶段也进行弱引用处理（reference processing）。
注意这个暂停与 CMS 的 remark 有一个本质上的区别，**那就是这个暂停只需要扫描SATB buffer，而CMS的remark需要重新扫描 mod-union table 里的dirty card外加整个根集合，而此时整个young gen（不管对象死活）都会被当作根集合的一部分，因而CMS remark有可能会非常慢。
4、**清理（cleanup）**：暂停阶段。清点和重置标记状态。这个阶段有点像mark-sweep中的sweep阶段，不过不是在堆上sweep实际对象，而是在marking bitmap里统计每个region被标记为活的对象有多少。这个阶段如果发现完全没有活对象的region就会将其整体回收到可分配region列表中。



## Collection Set

它记录了 GC 要收集的 Region 集合，集合里的 Region 可以是任意年代的。

> 不论是 YGC 还是 Mixed GC ，young generation 都包含在 CSet 里面。



## 如何解决跨代引用以及不同 Region 之间的引用

G1 在 Region 上都绑定了两个对象：

1.  Card Table 

> Card Table 使用类似 Bitmap 的形式，表示

1. Remember Set

## Remembered Set

[R大的解释](https://hllvm-group.iteye.com/group/topic/21468)

Remembered Set 是一种抽象概念，而 card table 可以是 remembered set 的一种实现方式。

**Remembered Set 是在实现部分垃圾收集（partial GC）时用于记录从非收集部分指向收集部分的指针的集合的抽象数据结构。**

分代式 GC 是一种部分垃圾收集的实现方式。当分两代时，通常把这两代叫做 young gen 和 old gen；通常能单独收集的只是 young gen。此时 remembered set 记录的就是从 old gen 指向 young gen 的跨代指针。

Regional collector 也是一种部分垃圾收集的实现方式。此时 remembered set 就要记录跨region的指针。

> RSet 从来不会保存从年轻代出发的引用，也可以说是指保存 old -> young 以及 old -> old 的引用路径。

逻辑上来说，每个 Region 都会有一个 RSet。

 YGC 的时候，只需要选定 young generation region 的 RSet 作为根集，这些 RSet 记录了 old->young 的跨代引用，避免了扫描整个 old generation。

 mixed gc 的时候，old generation 中记录了old->old 的 RSet，young->old 的引用由扫描全部 young generation region 得到，这样也不用扫描全部 old generation region。



## 参考资料

[Tips for Tuning the Garbage First Garbage Collector](https://www.infoq.com/articles/tuning-tips-G1-GC/)

