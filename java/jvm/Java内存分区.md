# Java 的内存分区



## 概述

![美团的图](assets/%E5%86%85%E5%AD%98%E5%88%86%E5%8C%BA.jpg)



JVM 的内存分区是逻辑上的概念，整体上可能还是一块内存。

按照是否线程私有来分，线程私有的区域如下：

1. PC - 程序计数器
2. Java 方法栈
3. 本地方法栈

共享的区域如下：

1. 方法区
2. 堆（Heap）



## PC - 程序计数器

指示的是当前执行程序的行号，每次执行完之后+1（指向下一条指令。

（**不确定内容**，猜测是根据方法栈栈顶方法确定所需要执行的指令地址，然后根据当前的计数器决定执行的方法指令行，因此在发生方法调用的时候 PC 置空；。



## Java 方法栈

Java 方法栈是 JVM 在执行 Java 代码的时候的主要结构。

Java 方法栈中最基础的结构就是栈帧，一个栈帧就表示一个方法，最底下的永远是 main 方法的栈帧，每次调用的时候会压入新的栈帧。

栈帧包含了以下几个成分：

- 成员变量表

保存方法参数以及内部定义的成员变量（以 Slot 形式）。

对于实例方法来说，表中第一个变量就是 this，指向当前实例对象。

- 方法返回地址

方法在结束的时候都需要返回被调用的地方。

方法的退出包含两种形式，一是正常的返回退出，而是二是异常退出。

正常退出时需要返回上层方法执行之前方法的后续流程，异常退出时需要将异常向上层方法抛出。

方法返回时的操作包含恢复上层方法的局部变量表和操作数栈，把该方法返回值压入调用者的操作数栈，调用程序计数器执行后面的指令。

- 动态链接 

Java 是支持动态分派或者说动态调用的语言，许多方法在最初并不知道最终的调用目标，因此只会在此处留下动态链接，最终调用时才会解析。

（动态链接就是符号引用，在类加载的时候部分可以确定的符号引用会直接被解析为直接引用，而部分不可确定的则作为动态链接保存。

方法的重载和重写就有此类区别。

方法的重载是指根据方法签名区分，相同方法名（不同于签名，签名包含参数类型）可以存在多个不同的方法，在类加载的时候根据调用的参数类型和数目就可以确定方法的直接引用此时就会被解析为直接引用（静态多分派）。

而重写就是继承并重新写方法逻辑，此时无法判断具体调用是父类还是子类，所以留下动态链接（动态单分派）。

- 操作数栈

所说的 Java 是基于栈执行语言，其中的栈就是指操作数栈。

Java 执行时的各种运算都是基于操作数栈实现的（区别于别的基于寄存器的语言。

Java 中实现一个简单的 c = a + b 的操作，会有如下几步操作：

1. 先将 a 取出并压入操作数栈
2. 将 b 取出压入操作数栈
3. 弹出栈顶两个元素相加，将结果压入操作数栈
4. 弹出栈顶元素赋值给 c

[R大的对栈式和寄存器式虚拟机的解释](https://www.zhihu.com/question/35777031)