# 垃圾收集器整理

## 概览

![常见的垃圾收集器](assets/%E5%B8%B8%E8%A7%81%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8.jpeg)

## G1

- [美团 - Java Hotspot G1 GC 的一些关键技术](https://tech.meituan.com/2016/09/23/g1.html)

- [搞懂 G1 垃圾收集器](https://www.cnblogs.com/GrimMjx/p/12234564.html)

- [G1 收集器原理的理解和分析](https://zhuanlan.zhihu.com/p/52841787)

  



### CMS

CMS 是实际意义上第一个并行的垃圾收集器，垃圾收集线程和用户线程同时进行。

## Parallel Scavenge 

> 通过 **-XX:+UseParallelGC** 和 **-XX:+UseParallelOldGC** 两种开启该回收器。
>
> 前者配合 Serial Old 垃圾回收器，后者配合 Parallel Old 垃圾回收器。

该垃圾回收器**默认启动了** **AdaptiveSizePolicy**，会根据 GC 的情况自动计算计算 Eden、From 和 To 区的大小。

可能会存在 From 和 To 被调整到只有不到 10M 的情况，此时如果遇到 YGC，很可能因为 Survivor 区溢出而导致存活对象全部晋升到老年代，如果配合的是 Serial 垃圾回收器，就会产生较大的延迟。

以通过如下控制该参数：

> **关闭：-XX:-UseAdaptiveSizePolicy**
>
>    **开启：-XX:+UseAdaptiveSizePolicy** 



### 参考

[JVM参数之UseAdaptiveSizePolicy](https://blog.csdn.net/u014263388/article/details/105617350)





### 相关定义

> 什么是 Full GC ？

Full GC 是收集整个堆的 GC，主要是老年代和新生代。

**在部分 GC 清理老年代的垃圾的时候，一般都会顺便触发一次 Young GC，也就组成了 Full GC。**

例如，**Parallel Scavenge（-XX:+UseParallelGC）框架下，默认是在要触发full GC前先执行一次young GC**。

还有 **CMS 在触发之后，最终标记之前可能会触发一次 YGC，尽量降低年轻代的内存占用。**



## 相关规则

### Young GC 的触发条件

1. Eden allocation failed （Eden 区分配失败 ）
2. 

### Full GC 的触发条件（非常重要）

1. 老年代空间分配失败
2. System.gc() 
3. JAMP histo:live 等 JVM 内存查看命令
4. 年轻代晋升担保失败。

### Survivor 溢出

在 Eden 回收之后存活的对象过多，无法放入 Survivor 区的时候，会直接晋升到老年代。

### 动态年龄计算

Hotspot 的实现中，除了满足  **-XX:MaxTenuringThreshold** 之外，还有一种动态的计算方式，简单来说，**Survivor 区中相同年龄的对象占 Survivor 区一半的空间的时候，大于该年龄的对象会直接晋升到老年代**



### 分配担保

## 相关参数

### -XX:SurvivorRatio

Eden 和 Survivor 比例，默认为8，比例为 8:1:1

### -XX:PreternureSizeThreshold

直接晋升老年代的对象大小，设置了这个参数后，大于这个参数的对象直接在老年代进行分配。

默认为空，不晋升。

### -XX:MaxTenuringThreshold

晋升老年代的对象年龄，对象在每一次Minor GC后年龄增加一岁，超过这个值后进入到老年代。

默认值为15

### -XX:+PrintTenuringDistribution

该参数是个日志型参数，用于输出 Eden 区中对象年龄分布。

```
Desired survivor size 107347968 bytes, new threshold 16 (max 30)
- age   1:    4345400 bytes,    4345400 total
- age   2:    2436856 bytes,    6782256 total
- age   3:     676112 bytes,    7458368 total
- age   4:    2323952 bytes,    9782320 total
- age   5:     599616 bytes,   10381936 total
- age   6:     563656 bytes,   10945592 total
- age   7:     567656 bytes,   11513248 total
- age   8:     815480 bytes,   12328728 total
- age   9:     527672 bytes,   12856400 total
- age  10:    3956032 bytes,   16812432 total
- age  11:   16575184 bytes,   33387616 total
: 1716581K->49462K(1887488K), 0.0345690 secs] 1739786K->72667K(3984640K), 0.0349280 secs] [Times: user=0.12 sys=0.00, real=0.04 secs] 
```

### -XX:+DisableExplicitGC

禁用显式 GC，开启该参数后 System.gc() 就不会触发一次 Full GC。

> Netty 中对直接内存的清理，是基于对 DirectByteBuffer 对象的显式回收，所以如果关闭该参数可能会在使用 Netty 等框架的时候出现堆外内存溢出。



## 相关资料

[GC参数解析 UseSerialGC、UseParNewGC、UseParallelGC、UseConcMarkSweepGC](https://blog.csdn.net/leo187/article/details/88920036#t5)

 