#### Java的关键字整理

	感觉`Java`的各类关键字也是面试的重点，所以在此处回顾和深入。

 	可能会有错误  (/ω＼)



---

###### volatile

- 用`Volatile`修饰变量有两个作用

  1. 保证其可见性

     >变量存储在`Java`的主内存中，线程使用时仅是拷贝一份到其私有的工作内存，而`Volatile`则是相当于某些时候使该变量在工作内存中的缓存失效，线程每次都会去主线程重新读取。

     

  2.  禁止`指令重排序`

-  `Volatile`能保证`可见性`，因为`禁止指令重排序`的特性也能一定的程度上保证`有序性`，**但不能保证`原子性`**

- `Volatile`的实现原理浅析

  - `Volatile`会在代码前加一个`Lock前缀指令`，实际上就是`内存屏障`,提供了以下的三个功能:
    1.  确保指令重排序时不会把其后面的指令排到之前的位置，前面的亦然。
    2. 强制对缓存的修改立即写入内存
    3. 如果是写操作，会导致其他`CPU`中的相关缓存无效



###### synchronized

- `Synchronized`是`Java`语言中常用的`同步`关键字，可以保证代码的`原子性`和`可见性`。
- 可以用来修饰`方法`和`代码段`，基础使用不做介绍。
  - 修饰**非静态**方法和代码段时，锁对象为***当前对象***。
  - 修饰**静态方法**时，锁对象为***类对象***。
- `Synchronized`的实现
  - `JVM`中的`Synchronization`是基于`Monitor（管程)`的进入和退出实现的，`Monitor`相关信息存储在`Java对象头`中。
  - `Synchronized`的实现原理 <font size="2">反编译图待补充</font>
    - `Synchronized`代码块
      - 代码块中的`同步`是显式实现的，通过反编译的代码也可以看出，通过`monitorenter `和`monitorexit`两条指令实现的加锁和释放。
      - `monitorenter`执行时，当前线程就会尝试获取`objectref`即对象锁对应的`monitor`的持有权力。
      - `monitorexit`在程序中会出现两条，因为退出考虑到出现异常时。
    - `Synchronized`方法
      - 方法中的`同步`是隐式的，并不会通过`monitor`相关的指令实现，而是通过`JVM`方法常量池中的表结构中通过申明`flags：ACC_SYNCHRONIZED`
- `Synchronized`的优化

  - `Synchronized`在1.6版本以前总是为重量锁，但是实际情况是有些时候代码中锁的竞争不会频繁甚至就不会出现，所以在1.6以后新增了一些对`Synchronized`的优化，包括引入`偏向锁`、`轻量级锁`，添加`自旋锁`，`适应性自旋锁`，`锁消除`，`锁粗话`等。

    - 锁的状态分为四种：`无锁`，`偏向锁`， `轻量级锁`，`重量级锁 ` <font size=2>(JDK1.6以上)</font>,且锁是**单向转换**的，即只能`无锁`->`重量级锁`。

      - `Synchronized`是的`重量级锁`的本质是使用`Monitor` 监视器实现，间接使用了操作系统底层的`Mutex Lock`，而相关操作涉及到从`用户态`切换到`核心态` <font size=2>(我也不懂 ，反正挺耗时间的(；′⌒“)</font> ，所以引入了`轻量级锁`的概念，主要就是为了解决在没有多线程竞争的情况下使用`重量级锁`导致的性能浪费。
        - 而`偏向锁`则是为了减少`CAS操作`而引入的锁，在锁获取的时候会将线程ID记录到`Mark Word`中，顺便设置`偏向标志位`为`1`，那么在进入一个同步代码段的时候会先检查`偏向标志位`，为`1`在检查`线程ID`，相同则跳过`CAS`直接进入代码。

    - `偏向锁`的获取过程：<font size=2> (简洁版) </font>

      > 1. 检查`Mark Word`的`是否可偏向`位，若为`1`则检查`线程ID`
      > 2. 一致，直接执行同步代码；不一致，通过`CAS操作`竞争锁，
      > 3. 成功，替换`Mark Word`中的`线程ID`，失败，在到达`全局安全点（没有正在执行的代码）`时膨胀为`轻量级锁`

    - `偏向锁`的释放：

      >  	偏向锁`不会主动去释放持有的锁，需要等待其他线程竞争,然后也是在`全局安全点`时撤销偏向锁，恢复`无锁的0/01状态`

    - `轻量级锁`的获取：<font size=2>(获取和释放阶段都有一些疑问，获取CAS失败之后为什么还要检查指针，释放CAS失败为什么表示其他线程在获取)</font>

      > 1. 检查`Mark Word`是否在无锁状态，若是则会在当前线程的桢栈中建立一个`Lock Record 锁记录`的空间，存储**锁对象**的`Mark Word`数据，官方称为`Didplaced Mark Word`，用于释放时的`CAS操作`。
      > 2. `CAS`操作将**锁对象**的`Mark Word`更新为`Lock Word`的指针。成功则变更`Mark Word`锁状态，失败则检查对象的`Mark Word`指针指向。
      > 3. 指向当前线程则执行同步代码，否则**膨胀为重量级锁**。

    - `轻量级锁`的释放

      > 1. 取出`Didplaced Mark Word`的数据,`CAS操作`替换锁对象的`Mark Word`，成功则释放成功.
      > 2. 失败表示其他线程在尝试获取，释放同时唤醒阻塞线程。



###### transient

- `transient`最基本的作用就是使一些敏感`属性不能被序列化`
- 一个类实现了`Serilizable`之后就能被序列化，但有些时候会希望只序列化一部分属性，而忽略一部分，此时就用到了`transient`。
- 注意:
  - `static`标记的静态属性不论是否被`transient`标识都不会被序列化。
  - `transient`仅能修饰属性。



