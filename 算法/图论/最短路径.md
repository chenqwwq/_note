

# 最短路径算法







## 概述



TIPS: 单源最短路径的几种求解算法

- 无权，采用BFS
- 有权，权重均为非负，采用 dijkstra
- 有权，权重包含负值，采用 bellman-ford





## Dijkstra 算法

Dijkstra 算法是以贪心 + BFS 的形式求单源最短路径的算法。

Dijkstra **只能用求非负权图。**

### 算法的基本流程

Dijkstra 算法将图的节点分为 S 和 U 两个集合，源点为 N，w[A,B] 表示节点 A 和节点 B 之间的权值。

- S 记录所有已求出路径的节点
- U 则是记录所有未求出的节点

<br>

初始时只有源点在节点 S，U 中和源点直接相连的为其权值，不相连的为正无穷。

每次从 U 中选择路径最短的节点放入 S，并更新集合 U 中的其他节点。

> 例如，节点 C 并不和源点 N 直接相连，但是和 B 相连，初始为正无穷。
>
> 但是在处理节点 B 的时候，节点 C 的距离变为 w[N,B] + w[N,C] 的距离，参与下一轮排序并选择。



```c++
class Solution {
private:
    int INF = 0x3f3f3f3f;
public:
    int handle(vector<vector<int>> &times, int n, int k) {
        // 有向正权图，求最长路径
        vector<vector<int>> graph(n, vector<int>(n, INF));
        for (auto &v: times) graph[a][b] = v[2];

        vector<int> dis(n, INF);
        vector<bool> vis(n, false);
        dis[k] = 0;
        for (int i = 1; i < n; ++i) {
            int cur = -1;
            // 选择离源点最近的节点
            for (int j = 0; j < n; ++j) {
                if (!vis[j] && (cur == -1 ||  dis[j] < dis[cur])) cur = j;
            }
            vis[cur] = true;
            for (int j = 0; j < n; ++j) dis[j] = min(dis[j], dis[cur] + graph[cur][j]);
        }

        int ans = -1;
        for (auto &distance: dis) ans = max(ans, distance);
      
        return ans == INF ? -1 : ans;
    }
};
```





## 例题

- [743. 网络延迟时间](https://leetcode-cn.com/problems/network-delay-time/)