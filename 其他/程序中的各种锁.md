

# 程序中的各种锁



## 悲观锁

## 乐观锁

## 自旋锁

（第一次听到自旋锁只在 Java 中，synchronized 使用了自旋锁。

在获取锁失败的时候不阻塞线程，而是无限轮询锁的状态，自旋的原因是锁可能只是短时间上锁，自旋一段时间可能比直接阻塞线程来的高效（阻塞线程涉及到用户态和内核态的切换，还需要保存线程的当前状态，换言之，自旋锁可以减少线程的调度和切换。

自旋锁有如下的问题：

1. 自旋锁无法保证锁获取的公平性（这个可以用排队自旋锁解决，或者设置等待次序和当前状态做比较
2. 无限自旋会浪费 CPU （设定自旋上限
3. 多核系统中，同时轮询并改变同一个状态会使缓存行频繁失效（CLH 队列以及 MCS 队列，CLH 和 MCS 都是单向队列，CLH 队列轮询前驱节点状态，MCS 轮询由前驱修改当前节点状态来做通知。