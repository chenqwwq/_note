## xv6 book 笔记



## Chapter 1

### 操作系统的接口

**内核是一个特殊的程序，为其他运行的程序提供服务。**

每个运行的程序称为进程，每个进程会有部分内存，包含指令，数据和堆栈信息。

当一个进程需要调用内核服务的时候，都需要通过调用 System Call（系统调用）实现，它就是操作系统对上层暴露的接口。

系统调用需要进行内核，因此在调用系统调用的时候用户进程需要在内核空间和用户空间之间切换。

内核使用 CPU 提供的硬件保护机制，确保每个进程都只能访问他自己的内存区域（内存区域会根据进程进行划分）。

当一个用户程序调用系统调用的时候，硬件会提升其权限等级，并且开始执行预先设定的内核中的方法。

系统调用的集合就是内核提供的可以给用户进程看到的。



Shell 用于读取用户命令并且执行，Shell 就是一个用户程序，并不是内核。



### 1.1 进程和内存

一个 xv6 的进程包含用户空间的内存（指令，数据，堆栈），每个进程的状态都会在内核中保存。

Xv6 的分时进程会在进程集合中切换 CPU 执行。

当一个进程不在执行的时候，xv6 会保存其寄存器信息，在它执行的时候重新恢复（所以切换核心进程消耗会更大，会涉及现场信息的切换。

内存保证一个进程唯一，每个进程都会有一个 PID。

（下面是 fork 系统调用相关

一个进程可以创建新进程，通过 fork 系统调用。

fork 创建的新进程拥有和原进程相同的内存数据（包括指令和数据），fork 会在原进程和新进程一起返回（并且继续执行之后的指令。

新进程会返回 0，原进程会返回创建的新进程的 PID。

常见系统调用：

| 系统调用             | 说明                       |
| -------------------- | -------------------------- |
| int fork()           | 创建新进程，返回子进程 PID |
| int exit(int status) |                            |
|                      |                            |









## 系统中断

trampoline.S



## 系统调用的流程







系统调用需要从用户态切换到内核态，保存当前堆栈信息并且加载内核的堆栈信息。







## QEMU

make qemu

make CPUS=1 qemu=gdb







## GDB

b main （在 main 函数中停止，等同于 break main

c 开始中断

si 执行下一条指令

layout split 上下布局
