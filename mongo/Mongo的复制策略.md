# Mongo Distributed Strategy

> Mongo的分布式策略

---

## 复制

复制是一个数据中间件保证其数据不丢失的有效途径，在很多的中间件中都有体现。

例如Redis的主从复制，以及Kafka的多分区，都是为数据保留一个副本，以防止意外情况丢失数据，并且在主节点暂时不可访问的情况下，希望能够顶替它，完成故障转移的操作，一定程度上保证高可用。

注意的是复制并不一定能提高读写性能，比如Kafka的多分区机制，他并不能增强读性能，反而会拖慢部分的写性能。



Mongo支持**一主多从，级联复制**的副本集(Rewplication Set)形式。

### 角色

![Diagram of a replica set that consists of a primary, a secondary, and an arbiter.](https://docs.mongodb.com/manual/_images/replica-set-primary-with-secondary-and-arbiter.bakedsvg.svg)



#### 主节点 Primary

主节点是Mongo副本集中**唯一接受并处理写请求的节点**，每个副本集最多只有一个主节点。



#### 次节点 Secondary

次节点就是数据的副本，次节点的数据只能从主节点导入并不会处理写请求，并且出于数据一致性的考虑默认情况下不建议对次节点发送读请求。

另外的Mongo的次节点又有一些特殊的属性配置：

1. Priority 优先级

优先级表示的是节点成为主节点的优先级，也就是说在主节点宕掉后，集群之间会通过Priority决定晋升资格。

Priority为0的节点就表示，该节点永远不能成为主节点，但它可以进行选举的投票。

2. Hidden 隐藏节点

同样是Priority为0的节点，和普通节点不同的是Hidden节点连读请求都不会接受。

选举时它也能正常进行投票。

3. Delayed 延迟节点

该节点是对隐藏节点的进一步配置，设置延时时间，比如设置为30min，那么该节点的数据就是主节点30min前的数据。

延迟节点可以作为数据的历史快照方便数据恢复。

比如人为的删库跑路，写请求会第一时间同步到次节点，但是对于该节点来说会延迟一定的时间，也就保存了数据的历史快照，可以以此为根据进行还原。

4. Vote 节点

投票节点，



#### 仲裁者 Arbiter

仲裁者并不是一个数据副本，它和其他节点的交互仅仅只有选举投票以及心跳。

因为Mongo的选举采用大多数的策略，所以可能有些时候会产生投票数五五开的情况，所以需要引入一个Arbiter节点增加一票解决问题。





### Oplog (Operate Log)

Oplog就是操作日志，类似于MySQL的binlog，会保存所有的写请求，副本集内所有的数据同步都是基于Oplog来完成的。

另外的由于其日志属性，又能作为一个数据恢复的功能点。

Oplog就是主节点中的一个固定大小的集合，默认情况下占5%的可用内存。





### Data Synchronization 数据同步

数据同步就是副本集中的各个节点保证数据的最终一致性的方式。

和Redis不同，Mongo中的次节点不是一定要从主节点同步最新的数据，它可以从任何比它领先的节点同步。



不过Redis和Mongo也有类似的地方就是同步的形式都分为两种(或许类似中间件都这尿性)

1. 全量同步(初始同步)
2. 增量同步





##### Intial sync 全量同步

全量同步就是从头开始，删除自身数据全盘接受副本集内其他节点数据的过程。

**主要步骤就是选取一个复制源，并且同步所有数据以及建立索引。**

因为Mongo并不是一定要求主从复制，所以当前节点的复制源选择就很讲究了，它并不一定是主节点，这点和redis非常不同。

非强制的主从复制可以有效的减轻主节点的带宽等的资源压力，所以Mongo能构建更多节点的主从集群，来满足频繁的写请求。

和选源息息相关的配置项就是[`initialSyncSourceReadPreference`](https://docs.mongodb.com/manual/reference/parameters/#param.initialSyncSourceReadPreference) 了，该配置项有以下几个值：

1. Primary - 只能从主节点复制
2. (default)primaryPreferred - 主节点优先，主节点无法访问则从其余节点中选择，
3. Secondary - 只能从从节点复制
4. secondaryPreferred - 从节点优先
5. nearest - 最近的，也就是网络延迟最小的liu

其他选择因素中，最关键的就是同步源和主节点的延迟不能超过30s。

选择好复制源之后的任务就是拉取oplog，并在当前节点重放。

在新版本(3.4之后，也不算新)，初始同步之后会建立所有在主节点上的索引，另外的在3.4之后，新增的oplog也会在初始同步时发送给次节点。



##### Replication 增量复制

增量复制就是全量同步之后主节点的写扩散过程。

次节点会不间断的发送oplog的拉取请求，如果获取到之后就在本地应用，

还有一个和Redis不同的地方就在于Mongo在选择完复制源之后还可以动态的替换，根据ping的延迟时间以及机器状态等等。





### Replica Set Elections 副本集选举

这里又是一个和Redis不同的点，Redis的主从结构并不提供故障转移功能，挂了就是挂了，从节点挂了就少个节点，主节点挂了就都挂了。

Redis中如果想要实现故障转移，避免单点问题，还得再加Sentinel节点，可能是面向的场景不同，Redis需要尽量保证存储的性能不受影响，所以不将故障转移等问题融合进主逻辑来也无可厚非。

扯远了，继续说Mongo的选举。



副本集是对数据的冗余，是Mongo作横向扩展，保证数据不丢失以及增强读写性能的策略，**而Mongo的选举就是Mongo突破单点故障的策略。**

因为副本集中只有主节点可以写入，如果主节点宕机那么整个副本集就处于不可写的状态了，对一个希望高可用的系统来说，选举就显得非常有必要了。



因为需要主动地触发选举流程，就要求每个节点都需要对其他节点作状态监测，也就是心跳包，Mongo默认间隔2s发送一次HeartBeat包(Ping包)，如果10s内没有响应就表示对方节点已经宕机。





