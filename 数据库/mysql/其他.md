## 排序相关

MySQL 中的排序算法包括三种：

1. 全字段排序

全字段排序就是将全部需要的字段放入 sort_buffer 统一排序后返回。

2. rowId 排序

在排序内容较多的时候，可能仅使用 rowId + 排序字段进行排序，然后回表查询另外的内容。

此时的效率可能非常低，因为先根据筛选字段查询 rowId 以及 排序字段（此时可能已经经过一次回表，而排序结束之后可能再次使用 rowId 进行二次回表。

3. 索引树排序

MySQL 索引本身就是有序的，因此如果排序条件满足索引（最左匹配原则，则可以直接使用索引中的顺序。

<br>

explain 的 Extra 字段中可能出现 filesort 标记，表示出现额外排序（并不一定是磁盘排序。



相关的还有分页问题，大数据量分页的时候可能会非常的慢，因为例如 limit 1000000,1000002; 此时会将 1000002 的数据全部先排序然后在选去后两条。

此时的优化应该减少待排序内容，使用索引或者子查询。







## 联表查询



联表查询包含如下几种形式：

1. 全连接/内连接查询

全链接查询最后的数据集只会保存驱动和被驱动表都匹配的数据。

例如 select * from a,b where a.id = b.id。

此时 a 和 b 的 id 在对方表中无匹配项的就不会被返回。

2. 左连接查询

3. 右连接查询



> 普通的 A join B，会是 MySQL 自行选择驱动表，而使用 A straight_join B，会固定 A 为驱动表。
>
> 驱动表可以简单理解为先查询的数据表，会根据驱动表的数据去匹配被驱动表。



**联表查询的时候应该是小表作为驱动，小表的判断依据是单个表执行完 WHERE 语句之后剩余的数据集。**



Index Nested-Loop Join

Simple  Nested-Loop Join

Block Nested-Loop Join