# 数据库事务相关



## 事务特性

事务的特性有如下四种，**原子性（Atomicity），一致性（Consistency），隔离性（Isolation），持久性（Durability）**。

<br>

原子性指的是事务的操作作为一个不可再分的整体，**要不同时完成要不同时失败**。

隔离性指的是**多个事务并发执行的时候，互相之间的可见性**，多个事务之间互相干扰的情况。

> 隔离性并不是说强制的完全不能看到，类似 InnoDB 提供了多种的隔离级别，低级别隔离也有使用场景。

持久性好理解，**就是保证数据不丢失，在事务提交之后，事务造成的变更就是永久性的。**

一致性指的是事务执行的前后，数据库中的数据都处于一种稳定状态，可能不太好理解，简单举例可以参考转账的操作，转账前后总额是不会增加的。



## InnoDB 中 ACID 的实现

首先是原子性，**InnoDB 使用 Undo Log 实现了原子性**，基本原则就是在失败之后回滚之前的操作。

> InnoDB 的 Undo Log 会根据数据行的版本指针组成一个链表，回滚时可以根据链表向上追溯。

**隔离性，InnoDB 的隔离性是依靠 MVCC 和 锁来实现的。**

InnoDB 中提供了多种不同的隔离级别，每个隔离级别使用不同类型的锁和 MVCC 表现形式来支持隔离性。

> 锁定义了事务并发时访问权限，MVCC 减少了部分上锁的情况（主要还是增加性能。

持久性，InnoDB 中的持久性是依靠的 redo log 以及 undo log 实现的。

> 并说不清为什么还需要 undo log，但是因为 WAL 机制，redo log 是在数据修改前就已经持久化的，在事务提交的时候可以保证 redo log 已经落盘了，大部分情况下 redo log 就已经能保障数据的持久性了。

一致性... emmm 不太清楚，应该是其他的东西一起保证的。



<br>

### InnoDB 下事务的隔离级别

MySQL InnoDB 中提供了四种隔离级别：

- READ UNCOMMITTED 读未提交
- READ COMMITED 读已提交
- REPEATABLE READ 可重复读
- SERIALIZABLE  序列化

<br>

四种隔离级别分别解决了不同的并发问题：

| 隔离解别            | 脏读 | 不可重复读 | 幻读 |
| ------------------- | ---- | ---------- | ---- |
| Read Uncommitted    | Y    | Y          | Y    |
| Read Committed      | N    | Y          | Y    |
| Repeatable(default) | N    | N          | Y    |
| Serializable        | N    | N          | N    |

> 简单理解一下这三种并发问题：
>
> **脏读，事务读取到了其它事务中未提交的数据。**
>
> **不可重复读，事务前后多次读取内容不一致。**
>
> **幻读，事务前后多次读取总量不一致。**

<br>

RC  解决脏读依靠的就是锁和MVCC。

> MVCC 在 InnoDB 的 RR 和 RC 级别下表现是不一样的，RR 级别下，MVCC 以第一次 SELECT 查到的数据为主不会再创建新的快照，但是 RC 级别下，MVCC 机制每次都会创建新的快照，所以也会存在前后数据不一致的情况。





## InnoDB 中的MVCC（多版本并发控制）

MVCC（**Multi-Version  Concurrency Control**） 在我看来是 InnoDB 中一个非常重要的特性，一定程度上提高了 MySQL 的并发性能。

MVCC 机制在数据行中保留了多版本的数据，使用数据行隐藏字段 roll_pointer（回滚指针）串联起一个版本链，可以顺着版本链回滚数据行。

基于 MVCC，InnoDB 引入了一个快照读的概念，相对应的还有当前读，快照读指的是当前查询语句读取的是快照的内容，当前读读取的就是当前的真实数据。

> 这里的快照不同于 Redis 的 RDB，是基于隐藏字段 trx_id 实现的可读范围标识。 

<br>

InnoDB 的行记录包含了两个隐藏字段：

| 字段名       | 含义                                 |
| ------------ | ------------------------------------ |
| trx_id       | 事务Id，由存储引擎统一下发，确保递增 |
| roll_pointer | 回滚指针                             |

回滚指针指向的是当前行上次的数据，以此形成一个版本链，如果需要回滚到最先版本的数据，需要顺着 roll_pointer 一直往上。

<br>

**MVCC 根据 trx_id 的大小界定出可见范围。**

事务开始时，会额外保存当前最大和最小的 trx_id，并且保存当前未提交的事务 trx_id 数组。

> 这里的事务开始是指第一次查询，而非 start tran。

小于最小的 trx_id 标识已经提交，所以可见，大于最大的 trx_id 表示开始时还未开启，所以不可见。

如果在中间，则判断 trx_id 数组是否包含来标识是否可读。



<br>

**MVCC 特性仅仅在 RC 和 RR 级别下生效，**并且在两个级别下的表现形式不同。

**在 RC 级别下，每次查询都会创建一个快照，而在 RR 级别下，只有第一次查询会创建一个快照。**（Important

> 这就导致了事务的表现不同。
>
> 在 RC 级别下，事务可以查看到别的事务已经提交的数据，这样就造成了不可重复读，也无法避免脏读。
>
> 而在 RR 级别下，事务只会以第一次查询语句为准创建快照，所以 RR 级别下不会出现所谓的不可重复读问题。



 

### 参考文档

- [相见恨晚，MVCC 这么理解，早就通关了](https://mp.weixin.qq.com/s/dMErouLlrte84Nmb97MkTQ)