# MySQL 索引相关



---

[TOC]



## 索引的结构

索引就是用来加速查询速度的结构，**常见的索引结构有B+树，B树或者 Hash 索引，倒排索引**。

> InnoDB 中以B+树为主，存在自适应 Hash索引，提供特殊形式的查询优化。

<bf>

B+ 树就是平衡的搜索树，可以简单理解为是二叉搜索树（BST）或者二叉平衡树（AVL）的变种。

AVL **就是任意节点左右子树的高度差不超过1的树，**为了维持这种特性需要大量的旋转操作，并且随着深度的增加搜索的效率也会慢慢降低，在动辄千万亿万的数据的数据库中，二叉搜索树明显是不合适的。

M 阶的B+树，根节点的节点数为[2,M]，索引节点的节点数为[M/2,M]，**而且保证了数据的有序性质**，所以层次更低，查询速度更快也更平稳。

> 因为B+树数据有序性的特点，所以如果不使用单调递增的索引键，在插入和删除操作时候就会存在页分裂和页合并的问题，十分影响效率。



B 树和 B+树 的区别如下：

1. B+ 树的所有数据都在子节点中，这样的**查询更加稳定**，所有的查询都需要树高度次的查询。
2. B+ 树所有的子节点**组成一个链表**，这样非常便于**实现范围查询**。

> 所有的数据都在子节点，而索引数据在非子节点，可以一次性加载尽量多的数据，或者直接将一个节点的数据封装为一个数据页，更有利于搜索。

相对于别的实现来说，B+树更加符合磁盘的特性。



Hash 索引应该是所有索引中速度最快的，插入和获取都可以达到理论的O(1)复杂度，但是 Hash索引 基本无法实现范围查询。

> 简单的例如 Redis，就可以理解为一个 Hash索引的优良实现。



> MySQL 为什么不使用 Hash 表或者跳表作为索引实现？

Hash 表只适合等值查询，几乎无法做范围查询。

为什么不使用跳表的原因如下：

MySQL 的主要数据还是保存在磁盘中，相对于跳表，B+ 树更加适配磁盘的特性，每个索引块可以保存在一个盘页。

（以 Redis 为例，如果纯内存的数据库跳表应该和 B+ 树访问速度差不多。





## 聚集索引和非聚集索引

聚集索引并**不是一种单独的索引类型，而是一种数据的存储方式**，在 InnoDB 中，主键索引就是聚集索引，**所有的数据都保存在主键索引的叶子节点中，数据按照主键的顺序排列存储。**

InnoDB 中，主键索引决定了数据的物理存储顺序，应该更能理解主键的乱序插入带来的页分裂等等问题了。

> 如果没有明确定义表的主键，MySQL 也会挑选一个唯一键作为主键，如果没有唯一键则会生成一个 rowId 作为主键。

非聚集索引就是非聚集索引，**和聚集索引相反的它的逻辑顺序和物理的存储顺序就是完全无关的。**

InnoDB 的实现中，次级索引都是非聚集索引，保存的是主键。

> 所以 InnoDB 中存在回表操作，就是在一个索引树中无法完全确定数据是否可用时，先返回主键，查询完整的数据再来判断。
>
> 增加单索引中字段，索引下推，索引联合都可以起到减少回表的作用。

MyISAM 中的非聚集索引实现不同，MyISAM 中所有的索引树都是非聚集索引，包括主键在内，保存的都是数据的真实地址。

> MyISAM 和 InnoDB 的不同在这里就有体现：
>
> MyISAM 支持没有主键，理论上来说 MyISAM 的主键索引和次级索引没有任何区别。
>
> MyISAM 的索引中保存的都是数据地址，而 InnoDB 的次级索引保存的主键。



## 稠密索引和稀疏索引

稠密索引会为每一个键值建立一个索引记录，可以i加快查询速度，但是需要更多的空战占用以及维护成本。（类似 MySQL 中的主键索引

稀疏索引不会为每一个键值建立索引，这种索引往往出现在有序的排序中，例如跳表结构就是稀疏索引的典型实现（Mongo 以及 Kafka 都算是稀疏索引，Mongo 的文档可能会缺失某些字段？Kafka 是以时间戳为序间隔一定长度建立索引项



## 简单对比下 InnoDB 和 MyISAM

1. InnoDB 支持事务，而 MyISAM 不支持。

> 不支持事务也就表示 MyISAM 无法提供有效的 ACID 保证，这对于某些需求来说非常致命。

2. InnoDB 支持外键，而 MyISAM 不支持。

> emmm... 其实无所谓，外键对上层业务也有产生约束，一般来说外键还是依靠上层业务来实现比较合适。

3. InnoDB 采用了聚集索引，每个表的主键索引就是聚集索引，而 MyISAM 只有非聚集索引，甚至可以没有主键。

> 如果说聚集索引定义了数据的物理存储的顺序，因为 MyISAM 没有聚集索引，所以也就没有明确的数据顺序，根据索引的不同会有不同的展现。
>
> 另外数据的无序，也就没有 InnoDB 的页分裂等问题。

4. InnoDB 支持行锁，甚至多粒度上锁，而 MyISAM 只有表锁。

> 在插入语句执行的时候，MyISAM 会锁住整张表，这个粗粒度的操作就会导致并发程度下降很多。

5. InnoDB 并没有保存记录数，而 MyISAM 保存了。

> emmm.  InnoDB 的 COUNT 基本上是要扫描的不管是二级索引树还是主键索引，而 MyISAM 的查找就是O(1)的时间复杂度。





## 唯一索引和非唯一索引

唯一索引就是在表内需要保证字段值全局唯一的索引。

> 唯一索引是保证不重复调用或者记录唯一的有效手段。
>
> 比如希望点赞数不重复被记录，那么就可以将帖子Id和用户Id组成一个唯一索引，确保一个用户只能对一个帖子点赞一次。

在 InnoDB 中唯一索引还会导致一些另外的问题，有好也有坏，但影响其实都不大，仅做了解：

1. 首先等值查询时，如果查找字段有唯一索引，那么查询到一条记录就会返回，而非唯一索引会顺着链表继续查询到一条不相等的记录。
2. 在插入或者修改数据的时候，InnoDB 的 Change Buffer 可能有效的减少随机读操作，而唯一索引无法使用该特性，因为在修改或者插入前都需要判断是否唯一



> Q：什么是 Change Buffer？

Change Buffer 早期又称为 Insert Buffer，在数据插入时生效，后面扩展到数据的修改。

Change Buffer 主要优化非唯一辅助索引的维护成本。

在涉及到数据修改时，如果记录所在数据页在内存中则直接修改，如果不在可能需要先加载再修改，此时这个加载过程就是随机读的过程，相对于顺序读而言随机读的效率低了不止一点点。

所以在修改的时候，InnoDB 会把这些更新操作缓存到 Changge Buffer 中，日志正常保存，即使宕机也能根据日志恢复。

保存在 Change Buffer 的数据在下一次读取到数据页时合并，也就是 Merge 过程。





## 最左前缀匹配

最左前缀匹配在联合索引中是一个非常重要的概念，**就是依据左前缀判断是否可以使用该索引。**

> 简单的例子，联合索引[a,b,c]，可是使用该索引的查询条件是[a]，[a,b]，[a,b,c]，但是绝对不包括[b,c]等不以a开头的查询条件

本质上来说，联合索引在 InnoDB 中的数据结构仍然是一棵 B+ 树，并且索引节点保存以声明顺序所表示的索引数据。

>  例如[a,b,c]，在索引树中的排序就是先按照a排序，a相同按照b排序，b相同按照c排序。
>
> ！！！利用索引有序的结构，可以完美的优化查询语句中的排序，但是在联合索引中，如果搜索条件是[a,b]并且按照b排序就不会出现文件排序，因为在a相同时，b本身就是有序的。
>
> 但是在搜索条件为[a,c]时，当a相同时，c并非有序，所以查询会出现 file sort。



## 前缀索引

前缀索引是指在一个长字符串字段中，可以选取其中N字节长度的前缀作为索引。

> 长字符串的索引除了使用前缀索引，还可以直接独立一个字段做hash，搜索会更加全面。



## 索引使用的相关算法

### 覆盖索引

覆盖索引是指在索引树中的内容已经包含了需要查找所需要所有字段，所以可以直接返回而跳过回表。

> 回表可以简单理解为使用二级索引查询获得主键之后，为了获得更多的数据而需要再一次扫描主键索引树。
>
> ！！一般来说扫描二级索引树获得的主键，会返回给 Server 层，由 Server 再次发起查询。

有些时候大量的回表会导致查询的效率十分低下，此时适当冗余索引字段也不失为一个好办法。





### 索引下推

索引下推是在 MySQL 5.6 引入的对索引使用方式的优化，在次级索引树的遍历过程中，尽量多的使用索引树中的字段。

> 在5.6之前，[a,b,c]索引查询[a,c]，只能使用到a字段，c字段就需要回表之后判断，如果a的筛率不高就会有大量的回表，
>
> 而在5.6以后，c字段也能下推判断，进一步的判断也减少了回表的记录数，加快了查询速度。



### 索引联合

索引联合了解的不多，在使用or的等值查询过程中可能会用到索引联合，搜索两棵索引树在做值的整合，相当于 union all 吧。





> 虽然索引有这好那好，但是走哪个索引还是依据优化器的，优化器也是根据抽样统计信息的，偶尔也可能出错。





### 建立索引的思考

1. 联合索引的字段排序（a，b，c 的联合索引，b 相对于 a 有序，c 相对于 b 有序，如果需要以a排序就可以建立（b，c，a 或者 c，b，a）索引，消除排序
2. 字段的区分度（比如 sex，存它干嘛呢，撑死了三个值
3. 实用程度（？，有些使用频率低的 SQL，可能并不需要特定的索引，索引也需要消耗一定的空间，并且降低更新和插入的效率。