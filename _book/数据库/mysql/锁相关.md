# MySQL 锁相关



MySQL 中的锁需要根据存储引擎的不同来说。

在 MyISAM 中仅仅只有表锁，所有的插入操作都需要事先锁表，而 InnoDB 支持表锁，行锁，甚至多级上锁。





## InnoDB 的基础锁类型

InnoDB 中根据划分依据的不同存在多种不同的锁:

根据锁的粒度，或者说锁的目标来划分，存在以下几种锁:行锁，表锁，间隙锁。

根据锁的强度来划分，存在写锁和读锁。





## 二阶段锁协议

在 InnoDB 中加锁的过程是根据语句的执行过程慢慢加的。

> 例如 `INSERT INTO ... SELECT ... FROM` 语句，该语句如果用于迁表，那么就会感觉到上锁的过程是根据语句的执行程度慢慢发展到锁表。

**而锁的释放是在事务提交之后一次性释放的。**

> 中间可能会有一些优化，类似于 AUTO_INCREMENT 带来的插入锁，会提前释放，并且一些行锁也可能提前释放，但总得来说大部分的锁都还是在事务提交时被释放的。



##  读锁和写锁

读锁和写锁是锁的两个程度，读锁就是所谓的排他锁，而写锁就是所谓的共享锁。

> Javaer 可以直接联想 ReadWriteLock。

读锁和读锁之间相互兼容，写锁排斥一切。

因为 MVCC 的存在，所以 MySQL 的查询一般来说是不会上锁的，强行上锁可以使用以下语句加锁：

```mysql
// 读锁
SELECT * FROM tableName WHERE ... LOCK IN SHARE MODE
// 写锁
SELECT * FROM tableName WHERE ...  FOR UPDATE
```

划分读锁和写锁的意义就在于，让两个读锁可以通知执行，增加并发度。



## 行锁和表锁以及意向锁

根据粒度划分，InnoDB 中存在行锁，也就是对表中的单行记录上锁，也有表锁，可以对整张表上锁。

> ！！！InnoDB 中并没有真正意义上的表锁，就是直接对表上锁的那种，而是通过行锁+间隙锁的形式锁表。

**对于常规的 CURD 语句，判断行锁还是表锁，简单来看就是是否走索引，不走索引的 CRUD 语句都会经过一个全表扫描的过程，扫描过程中慢慢的就会锁表。**



InnoDb 支持多粒度上锁，即表锁和行锁，如果表锁和行锁都为读锁，那也不会冲突，而如何在上表锁的时候判断是否在表中存在行锁就会出现问题，总不能扫表来判断是否有锁吧，此时就出现了意向锁。





## GAP 锁

GAP 锁的锁定目标就是两个索引记录之间的区域（左开右闭），GAP 锁的目的就是为了防止其他的事务在间隙（GAP）范围内插入数据。

GAP 锁是共享锁，也就是说两个事务可以同时对相同的 GAP 上锁。

GAP 锁仅仅在 RR 级别下生效。





## Next-Key Lock

Next-Key Lock 就是**行锁和 GAP 锁的结合**，GAP 锁锁定的是命中的索引记录之前的间隙。

Next-Key Lock 的存在使 InnoDB 在 RR 级别下面就可以解决幻读问题。





## 死锁

死锁出现的情况就是互相持有对象需要的锁。

> 例如，持有A资源，等待B资源的线程和持有B资源，等待A资源的线程会造成死锁。

如何避免死锁（减少死锁的发生：

1. 缩小事务范围

> MySQL 的上锁是逐步的，扫描索引树的时候逐步上锁，并且在事务提交的时候才会释放，所以缩小事务范围可以有效减少死锁的发生。
>
> 因为事务的解锁统一在事务的提交的时候，所以即使不同表的更新也会造成死锁。

2. 尽量使用主键索引更新语句

> 避免对索引树的扫描导致一次更新覆盖太多的行。

3. 在一定情况下可以使用 RC 模式执行更新语句

> RC 模式不会上 GAP 锁，可以减少上锁范围，也就减少了死锁的出现

4. 非即时更新串行化

（有待商榷





## Reference

[史上最全的select加锁分析(Mysql)](https://www.cnblogs.com/rjzheng/p/9950951.html)

