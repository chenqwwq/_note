
这本书看完也有两个月了,时间过得很快,期间我还看了`MySQL技术内幕-InnoDB`,也完成了总结,不知道为什么这个总结

却一直拖着,可能时拖延症吧.

最近的感觉除了迷茫还是迷茫,我不想在小公司度过我的编程生涯,也听别人说前面几年的积累和见识至关重要.我是想

往纯后端技术的方向走,但无奈两个公司都是外包,积累不起什么拿得出手的项目经验,在小公司迷茫的还是技术方面的

方向,我知道现在分布式技术的重要性,有朋友实习面试都被问到了,但这种大公司必备的技术,小公司却用不上,学习也发

现自己太多地方需要补充,我有过离职回家学习的念头,但最近的寒冬让我有点不敢迈出这一步.

唉,努力吧. 努力会得到幸运的.太多话只能自己小声念叨了.

写总结可能会有很多原文作为摘抄,只是为了整理整个的知识体系或者结构便于记忆,也便于以后复习.

​																			2019年1月21日



## 一.自动内存管理机制

望文生义**就是JVM里一套自动管理分配的内存区域的机制.**

![](https://chenbxxx.oss-cn-beijing.aliyuncs.com/JVM%E8%BF%90%E8%A1%8C%E6%97%B6%E5%86%85%E5%AD%98.jpg)

### 1. Java运行时内存     区域

是为了方便内存管理在程序运行时做出的逻辑上的区域划分.从访问来说分为可以分为**线程共享区域和线程独占区域**.

线程私有区域包括:

- [程序计数器](#程序计数器)
- [Java虚拟机栈](#Java虚拟机栈)
- [本地方法栈](#本地方法栈)

线程共享区域包括:

- [Java堆](#[Java堆)
- [方法区](#方法区)

#### 程序计数器

程序计数器是一块**线程私有的**小区域,是当前线程所执行的字节码行号指示器.类比于CPU中的PC.

可以通过改变这个计数器的值来获取下一条字节码指令的地址,包括**分支,循环,跳转,异常处理,线程恢复等基础功能**.

如果执行本地(Native)方法,该计数器值为空.无`OOM异常`情况.

#### Java虚拟机栈

和线程生命周期一致,属于线程私有的一块区域.是**堆,栈**划分中的`栈`.

在我的理解中,`Java虚拟机栈`结构就是一个`FILO`的栈的形式,**每个方法的生命周期都有对应的出栈和入栈**.例如`main`方法最先入栈就在最底部,然后往上叠加调用的各种方法.线程执行完毕后栈帧全部出栈.

![](https://chenbxxx.oss-cn-beijing.aliyuncs.com/Java%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%A0%88.jpeg)

如上图所示,每一个栈帧中会存储这**局部变量表,操作数栈,动态链接,方法出口信息等**.

**局部变量表中存放了编译器可知的各种基本数据类型(boolean,int,byte等),对象引用类型,以及`returnAddress`.**

局部变量表所需的内存空间在编译期就时确定并完成分配的.在运行期不会改变.

该区域会因为请求栈深度超出允许抛出`StackOverflowError`,也会因为允许却无法扩展得到所需要的内存时跑出`OOM`

#### 本地方法栈

类同于Java虚拟机栈he,本地方法栈是用来辅助`本地Native方法`的调用.

同样会抛出`SOE`和`OOM`.

#### Java堆

是线程共享区域,同时也是`JVM`管理的内存中最大的一块区域.

`Heap`的作用就是存放对象实例.`JVM`中大部分的对象实例都会存放在这里.

`Java堆`在很多时候也被称为`GC堆`,因为它是`GC`活动的主要区域.

同时,因为`HotSpot`的`垃圾分代收集策略`所以在`HotSpot VM`中又可以细分新生代和老年代.

新生代再细分还有`Eden区`,`From Survivor区`,`To Survivor区`.主要内容`GC`再细说.

![](https://chenbxxx.oss-cn-beijing.aliyuncs.com/%E5%A0%86%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B2.png)

另外`Java堆`并不需要内存空间实际物理连续,仅逻辑连续即可.

#### 方法区

线程共享的内存区域,以`GC分代收集策略`来说属于`永久代(Perm Space)`.<font size="2">HotSpot的Jdk8版本中完全移除了永久代的概念</font>

方法区中存储已被`JVM`加载的**类信息,常量池,静态变量,即时编译后的代码等数据.**

常量池即为运行时常量池,是Class文件被加载到内存后,存放在各个类的`Class文件的静态常量池`**中字面量(Literal)和符号引用(SymbolicReferences)部分**

**符号引用转译出来的直接引用也会存储到运行时常量池.**

运行时常量池具有`Class文件常量池`不具备的**动态性**,e.g.可在运行时调用`String::intern`使常量入池.

字符串常量池是全局共享的区域,内部构造就是一个`StringTable`的Hash表,在`JDK1.7`中连同运行时常量池中的字面量部.分转移到了`Java Heap`中.

**JDK1.7中运行时常量池被移出方法区,其中字面量部分转移到堆中,符号引用部分转移到本地内存.**



### 2. Java对象的内存布局

简单来分,`Java对象`的内存布局可以分为`对象头(Header)`,`实例数据(Instance Data)`,`对齐填充(Padding)`

#### 对象头

`对象头`中包含了`Mark Word`和`类型指针`两块内容.

如果是数组对象,那么对象头中**还需要一块区域记录数组的长度**.

##### Mark Word

![](https://chenbxxx.oss-cn-beijing.aliyuncs.com/Mark_Word.png)

`Mark Word`中存储着对象的`HashCode`,GC年龄分代,锁状态标志,线程持有的锁,偏向锁偏向的线程ID,偏向时间戳等.

为了在小空间尽量多的存储信息,`Mark Word`的大小并不是固定的,有些数据会在重复的空间内相互覆盖.

`Mark Word`在32位和64位的虚拟机中,分别为32bit和64bit.

`Mark Word`中的锁信息相关可以查看 - [Synchronzed&锁优化](https://github.com/CheNbXxx/StrugglingInJava/wiki/Synchronzed&%E9%94%81%E4%BC%98%E5%8C%96)

##### 类型指针

`类型指针`即对象指向其类元数据的指针.

#### 实例数据

`实例数据`就是对象的有效负载,是真正存储有效信息的区域,里面存储这程序代码中定义的所有字段信息.

#### 对齐填充

因为`JVM自动内存管理机制`中对象的起始地址必须是bit的整数倍,所以`Java堆`中保存的对象大小也必须是8的整数倍.

在未达到时,就需要这些填充字节.



### 3. 对象的引用实现

`Java`中想要操作的对象都需要通过栈上`reference`类型数据,进而定位,获取到需要操作的对象地址.

**根据虚拟机的不同,对象的访问方式可以分为`句柄`和`直接指针`两种.**

#### 句柄

**栈上的`reference`保存的是句柄池中该对象的句柄地址,而该句柄中保存了实例数据以及类型的元数据地址.**

简单来说句柄是链接一个对象引用和对象多种数据之间的关联.是第三方媒介作用.

**此时对象的元数据和实例数据时完全分离的,从对象的实例数据无法定位,获取到元数据.**

![](https://chenbxxx.oss-cn-beijing.aliyuncs.com/java%E5%8F%A5%E6%9F%84.jpg)

#### 直接引用

`直接引用`表示**栈上的`reference`直接指向堆中对象实例的地址.而元数据的地址则保存在每一个对象实例数据中.**

例如前面所说的`对象头`中的类型指针.因此可以直接从对象头知道对象所属类型.

所以此时元数据是和每个实例数据都存在关联的.

![](https://chenbxxx.oss-cn-beijing.aliyuncs.com/java%E7%9B%B4%E6%8E%A5%E6%8C%87%E9%92%88.png)



#### 优势对比

句柄最大的优点就在于`reference`中存的是句柄池,就算对象的位置再怎么变,只要修改句柄指向就好而无需修改栈上的`reference`.

直接指针的优点在于访问速度,没有句柄的关联从指针直接找到对象.当对象位置改变时栈上的`reference`也需要改变.

**`HotSpot`采用的是直接指针的方式.**



### 4. Java对象的创建流程

在Java语言中`new`是创建实例对象,为其在堆中分配空间的关键字.

以下为`JVM`接收到`new`指令之后的操作:

1. 首先会在**类的运行时常量池中查找对应的引用**,并检查是否该类型是否加载到`JVM`中,如未加载则先执行类加载的过程.
2. 在类加载通过之后就会为实例对象分配`Java堆`中的内存
   - **一个对象需要多少内存在类加载时就可以确定**
   - 针对内存空间是否有碎片,分配方法可以分为`指针碰撞`以及`空闲列表`.
   - 此间为了保证分配内存操作的并发性,可使用`-XX:+/-UseTLAB`,设置每个线程在`Java堆`中预先分配空间.`TLAB`纪为本地线程分配缓存-`Thread Local Allocation Buffer`.
3. 之后初始化所有分配空间为`0`值
4. 设置对象的`对象头`,其中包含了`类型指针`,`对象Hash`,`GC年龄分代`等信息.
5. 调用`<init>`方法,即构造方法和初始代码块等,完成进一步的初始化.

#### 内存分配策略

内存的分配是采用`指针碰撞`还是`空闲列表`是由内存空间是否规整决定的.而Java堆内存是否规整则取决于采用的GC算法.

GC算法是否带有整理的步骤**决定了GC的空间是否会留有碎片.**

类似于`Serial`和`ParNew`等执行`标记-整理`或者`复制`算法的收集器,收集之后不会有碎片的存在.所以采用的是`指针碰撞`的分配算法.

而`CMS`等采用`标记-清除`算法的收集器,GC过后可能会留下大量的碎片,所以采用的就是`空闲列表`.



---

## 二.垃圾收集器与内存分配策略

### 1.  "垃圾"判定

判断对象是否可以被回收,通常有两种算法:`引用计数`和`可达性分析`

#### 引用计数算法

每个对象分配一个引用计数器,有地方引用则计数器加一,反之则减一.

有一个致命的缺点就是:**引用计数算法无法解决循环引用!**

#### 可达性分析

当前`HotSpot`采用的判定算法.

算法的原理就是**以一些`GC Root`节点为根节点**,向下搜索,搜索所走过的路称为引用链,能搜索到的对象即为`可达`,当一个对象没有任何引用链关联到它是,就会被判定为`不可达`

在Java语言中,可以作为`GC Root`的对象包括下面几种:

1. 栈(栈帧)中引用到的对象.
2. 方法区中类静态属性所引用的对象
3. 常量池中引用的对象
4. 本地方法栈中JNI所引用的对象.

注意:**要完全判定一个对象无用,至少需要经历两次标记过程.**

### Java的四种引用关系

Java中的引用从关联的强到弱依次为:**强引用 -> 软引用 -> 弱引用 -> 虚引用**

最常使用的`new`创建的引用关系就是强引用.

具体的引用关系:<font size="2">(我github的笔记)</font>

[Java中的四种引用关系整理](https://github.com/CheNbXxx/StrugglingInJava/wiki/Java%E4%B8%AD%E7%9A%84%E5%BC%95%E7%94%A8%E5%85%B3%E7%B3%BB)

### 3. 方法区垃圾的回收

方法区若按照`GC分代策略`属于永久代,但不意味这这块内存是永久存在的,只是这块区域的内存回收相对于`Java堆`来说跟家困难且效率极低.

方法区的收集任务主要有:**无用常量和废弃的类.**

方法区中**废弃的类**的判定也相对来说严格很多:

1. 类所有实例都已经被回收.
2. 类的`ClassLoader`已经被回收.
3. 类的Class对象(类对象)没有在任何地方地方被引用.

需要注意的是:即使以上条件全部满足,也仅仅是可以回收,会不会回收还得看虚拟机心情.

### 4. 垃圾收集算法

 当前常用的垃圾收集算法一般分为三类:`标记-清除(Mark-Sweep)`,`复制(Copy)`,`标记-整理(Mark-Compact)`

#### 标记-清除算法

![](https://chenbxxx.oss-cn-beijing.aliyuncs.com/%E6%A0%87%E8%AE%B0%E6%B8%85%E9%99%A4%E7%AE%97%E6%B3%95.png)

该算法分为`标记`和`清除`两个步骤,首先`标记`步骤负责标记出所有需要回收的对象,之后`清除`步骤中清除所有被标记的对象.

标记算法的缺点非常明显

- 标记和清除两个步骤的效率都不高.
- 清理后没有内存的整理步骤,所以产生大量的内存碎片.会导致以后很难为一个大对象分配空间.

#### 复制算法

![](https://chenbxxx.oss-cn-beijing.aliyuncs.com/%E5%A4%8D%E5%88%B6%E7%AE%97%E6%B3%95.png)

复制算法就是隔离一块内存空间并将收集时存活对象复制到这片空间,而完全清除另外一块空间.

复制算法的缺点也非常明显:就是内存使用率不高,始终会有一片空间闲置.

现代的复制算法将堆划分为`Eden`,`From Survivor`以`To Survivor`三块内存区域.

`minor GC`触发时会将`Eden`和`From Survivor`的存活对象都移动到`To Survivor`区域,再将`To`和`From`区域互换.

#### 标记-整理算法

![](https://chenbxxx.oss-cn-beijing.aliyuncs.com/%E6%A0%87%E8%AE%B0%E6%95%B4%E7%90%86%E7%AE%97%E6%B3%95.png)

相对于`标记-清除算法`,`标记-整理算法`就是多了一个`整理`的步骤,会讲内存重新整理,去除内存碎片.

而缺点更加明显:多了一个`整理`步骤后会进一步拉低了GC效率.

### 5. 分代垃圾收集策略

当前各类虚拟机所使用的主要垃圾手机策略,就是将需要GC的区域划分分为不同的模块,一般来说都是`新生代`和`老年代`<font size="2">(HotSpot1.8之前还有永久代的概念,1.8之后被完全移除)</font>

针对每个分代的特性选取不同的垃圾收集算法

- 新生代中的对象一般`朝生夕死`,最终只有少量存活.所以采用**复制算法**
- 老年代中的对象存活率相对较高,如果采用复制算法会需要更大的担保内存,所以一般采用`标记-清除`或者`标记-整理`算法.

### 6. Full & Minor GC

根据收集的区域的不同,触发的GC也有不同的命名,从理论上的性能消耗来说从小到大依次为:`Minor GC -> Major GC -> Full GC`.

#### Minor GC

我的理解中`Minor GC`等同于`Young GC`,都是**专门针对新生代的GC**,所以在新生代的`Eden区`满了之后就会触发.

#### Full GC

`Full GC`就是对新生代,老年代和元空间的全GC.<font size="2">(其实我感觉怪怪的,元空间好像并不属于GC分代里的概念)</font>

**因为`Major GC`之前也会进行至少一次的`Minor GC`,所以一般来说`Major GC`约等于`Full GC`**

**此块内容代补充**



### 7. 垃圾收集器

![img](https://upload-images.jianshu.io/upload_images/4685968-3a367913acebef67.png?imageMogr2/auto-orient/)

`JVM`中垃圾收集器一般都是搭配使用的,因为没有一种收集器能完美的满足GC的所有需求.

图中连线表示两个收集器可以搭配使用.

#### Serial收集器

`Serial`是款的单线程的收集器,在收集时需要暂停其他线程的工作,也就是`STD(Stop The World)`,直到GC完成.

`Serial`工作在新生代,也就是图中的年轻代.

`Serial`采用的是`复制算法`

#### ParNew收集器

简单来说,`ParNew`就是`Serial`的多线程版本,同样工作在新生代,并采用`复制算法`,

`ParNew`和`Serial`甚至共用了大部分的代码.

默认开启的线程数目和当前主机`CPU`数目相同,且可用`-XX:ParallerGCThreads`参数设置.

#### Parallel Scavenge收集器

`PS`收集器和`ParNew`也是一个多线程的收集器.

`PS`收集器的目的可能和别的收集器不同,它的目标是达到一个可控制的吞吐量(Throughput).

简单介绍一下,`吞吐量`就是CPU用于运行用户代码的时间和CPU消耗的总时间的比值.此处可简单理解为:

**吞吐量 = 运行用户代码的时间 / (运行用户代码时间 + GC总时间)**

`PS`收集器也被称为**吞吐量优先**收集器

`PS`收集器的主要参数:

- **-XXMaxGCPauseMillis** - 设置最大GC停顿时间.单位为ms
- **-XX:GCTimeRatio** - 设置吞吐量大小,单位为百分比
- **-XX:+UseAdaptiveSizePolicy ** - 开启GC自适应调节策略

`GC自适应调节策略`开启之后`JVM`会根据即时的运行参数修改以下参数:

- **-Xmn** - 新生代大小 
- **-XX:SurvivoprRatio** - `Eden`和`Survivor`的大小比例
- **-XX:PretenureSizeThreshold** - 直接在老年代分配内存的大小阈值,需要内存大小超过这个值就直接进入老年代.

#### Serial Old收集器

`Serial`收集器的老年代版本,收集算法从`复制`变为`标记-整理`算法.

#### Parallel Old收集器

`Parallel Old`是`Parallel Scavenge`收集器的老年代版本,收集算法变为了**标记-整理**算法.

#### CMS(Concurrent Mark-Sweep)收集器

是一款有非常重要的意义的收集器,从名字中也可以看出采用的是`标记-清除`算法.

`CMS`收集器的目的是为了获取最短回收停顿时间的收集器,停顿时间短就不会影响业务代码的运行.

`CMS`收集器的步骤:

1. 初始标记
2. 并发标记
3. 重新标记<font size="2">(在并发标记时产生的引用关系的变化,所以需要重新标记)</font>
4. 并发清除

步骤中1,3两部都会导致`STW`,初始标记仅仅只会标记`GC Root`能直接关联到的对象,并发标记则是进一步标记,而重新标记则是标记在`并发标记`这段时间中被修改的引用关系.

`CMS`收集器的缺点:

- 多线程敏感
- 无法清理浮动垃圾(Floating Garbage)
- `标记-清除`算法导致的内存碎片化问题.

`CMS`收集器的相关参数:

- **-XX:CMSInitiatingOccupancyFraction** - 设置GC时老年代所使用的内存百分比.如果余下的供工作线程使用的空间不足,则会导致`Concurrent Mode Failure`,JVM会临时启用`Serial Old`收集器进行另外一次`Full GC`.
- **-XX:+UseCMSCompactAtFullCollection** - 开启GC之后的内存整理步骤,消除内存的碎片化问题.
- **-XX:+CMSFullGCsBeforeCompaction** - 指定内存整理间隔的`Full GC`次数,默认为0.

#### G1收集器

当前最最牛*的收集器.



### 8. 对象内存管理的几条原则

#### 1. 对象优先在Eden分配

在绝大多数情况下,对象在新生代的`Eden区`分配所需空间.

#### 2. 大对象直接进入老年代

所谓的大对象就是指需要大的连续内存的对象,比如Java中的数组<font size="2">(Java中的数组为真数组)</font>

上文也提到,JVM提供了参数**-XX:PretenureSizeThreshold**来设置大对象的阈值.

#### 3. 长期存活的对象进入老年代

上文提到的`Java对象头`的`Mark Word`中保存的对象`GC年龄分代`,就是要用于此处.

堆中的对象每经历一次`GC`,这个字段就会对应的加1,当到达一定的阈值后就会晋升到老年代.

所谓阈值可以使用**-Xx:MaxTenringThreshold**设置,默认为15.

所以每次`Minor GC`之后会观察到老年代的使用内存会增加,就是因为有对象晋升.

#### 4. 动态对象年龄判定

这个是`JVM`默认的设置,`Survivor`中的对象并不是一定要达到阈值才会晋升

**`Survivor`区中相同年龄的对象占的大小总和大于整个`Survivor`空间大小的1/2,此时年龄大于或等于的对象就可以批量直接晋升到老年代;**

#### 5. 空间分配担保

执行`Minor GC`之前,`JVM`会先检查**老年代最大可用的连续空间**是否大于**新生代所有的对象总空间**,以此作为老年代是否有足够空间容纳晋升对象的依据,大于则直接进行`Minor GC`.

如果小于则会继续判断**HandlePromotionFailure**以执行另外的操作

- 若**-XX:+HandlePromotionFailure=true**,则允许空间分配担保,则会继续判断**老年代最大的可用且连续空间大小**是否大于**历次晋升到老年代对象的平均大小**.
  - 若大于,则会先触发一次`Minor GC`.
  - 若小于,则会先进行一次`Full GC`.

- 若**-XX:-HandlePromotionFailure=false**,则会直接进行一次`Full GC`.

采用平均大小的对比来估计老年代是否可以承受此次晋升并不一定准确,老年代可能仍然不能承受此次晋升,这时就会触发一次`Full GC`.



---

中间跳过了调优和Class文件结构两章.待补充

Class文件结构: 魔数+次版本号+主版本号+常量池

---

## 三. 虚拟机类加载机制

类加载机制的功能就是通过一个类的全限定名读取此类的二进制流，通过**加载，验证，准备，解析，初始化**将其转化为对应的`java.lang.Class`对象。

类型的加载,连接,初始化等过程都是在程序运行期间完成的。

### 1. 类加载的时机

类加载的过程可以简单分为:**加载,验证,准备,解析,初始化**,这些步骤通常都是互相交叉混合式的运行.

JVM并没有规定进行`加载`的具体时间,但是最后一个`初始化`阶段,**有且仅有**以下五种情况会触发:

1. 遇到`new`,`getstatic`,`putstatic`,`invokestatic`四条指令.
2. 使用`java.lang.reflect`包的方法对类进行反射调用的时候
3. 初始化子类时发现父类未初始化,先初始化父类.
4. 虚拟机启动时,必须先初始化主类.
5. 使用JDK7的动态语言支持,如果一个`java.lang.invoke.MethodHandle`实例最后的解析结果是`REF_getStatic`,`REF_putStatic`,`REF_invokeStatic`的方法句柄,且方法句柄对应的类未初始化.

### 2. 类加载的过程

#### 1. 加载

首先要明确`加载`是`类加载`的第一步,两者不要混为一谈.

`加载`的具体流程如下:

1. 通过**类的全限定名**来获取此类的二进制流.
2. 将这个字节流对应的静态存储结构转化为方法区的运行时数据结构.
3. 生成一个类对象(Class对象),作为方法区这个类各种数据访问的入口.<font size="2">（注意是方法区）</font>

对于数组来说,它是通过`JVM`直接创建的并非通过`ClassLoader`,但数组的元素类型还是需要经过`ClassLoader`加载的。

JVM中数组的创建有以下三个原则：

1. 如果数组元素的类型是引用类型,则创建时需要先加载这个类型.<font size="2">(不包括初始化)</font>
2. 如果数组元素类型是基本类型,JVM则直接将数组标记和对应类加载器关联。
3. 数组类的可见性和它的组件类型一致,如果是基本数据类型默认就为`public`.

#### 2. 验证

`验证`和`加载`两个阶段是有一部分重合的,在加载未完成时<font size="2">(因为文件格式验证是针对字节流的,此处推测是获取到二进制流之后到转化结构之前)</font>就开始`验证`的第一个环节`文件格式验证`。

`验证`是为了确保Class文件的字节流中符合当前虚拟机的规范,并且不会对虚拟机自身的运行造成危害。

整个验证流程可以分为：

1. **文件格式验证**

   **和`加载`交叉运行的环节**,会检查字节流开头是否为魔数,版本号是否正确的等信息.

   经历过这个验证之后,字节流会转化为方法区内的字节码文件,而接下来的验证环节都是基于字节码的.

2. **元数据验证**

   该环节会对字节码所描述的信息进行分析,保证其符合规范.

   在我理解中该环节是检查**类级别的信息**,包括继承关系,是否有父类等.

3. **字节码验证**

   而字节码验证则是**偏向于对方法体和类内部的验证**

   对数据流和控制流进行分析,确保其中语义合乎规范和逻辑.

4. **符号引用验证**

   **该环节的验证发生在解析环节中符号引用转化为直接引用的部分.**

   确定符号引用可以找到对应的类型,以及引用的访问权限是否规范等.



#### 3. 准备

准备阶段是**正式为`类变量`(static变量,静态变量)分配内存并设置初始值的阶段.**

上文有提到,1.7之前静态变量都是在方法区分配内存的,而1.7之后静态变量的区域和运行时常量池部分一起移动到堆中.

此时设置的初始值是***JVM设置的**.例如`int`会被初始化为0,`boolean`会被初始化为`false`等.



#### 4. 解析1

**解析阶段就是将常量池中的符号引用转化为直接引用的阶段.**

注意是`常量池`中的符号引用，而且此时也是`验证`最后一个环节`符号引用验证`的执行时间。

JDK1.7中符号引用被移动到本地内存,1.8中可能被归纳到元数据区。

解析动作主要针对**类或接口，字段，类方法，接口方法，方法类型，方法句柄，调用点限定。**

解析阶段主要包括一下几种解析：

1. 类或接口解析
2. 字段解析
3. 类方法解析
4. 接口方法解析



#### 5. 初始化

初始化就是按照程序员自己意愿修改**类变量**属性的阶段，也是程序执行类构造器`<clinit>()`方法的过程。

`<clinit>()`由程序**收集代码中对类变量的赋值操作，以及静态初始块(static{})**合并而成。<font size="2">(所以静态初始块是优先于构造方法执行，且只会执行一次的，因为它是在类加载的过程执行,收集构造方法产生的是<init>)</font>

 

### 3. 类加载器

在JVM中，**对于任意一个类都需要对应的类加载器和类本身一同确定其唯一性。**

例如在JDK1.8中，元数据区就会以类加载器为单位分配空间，使类加载器和类对象的生命周期统一。



### 4. 双亲委派机制

类加载器可划分为以下三种：

1. **启动类加载器(Bootstrap ClassLoader)**

   负责加载系统环境`<`JAVA_HOME>/lib`下的类库。

2. **扩展类加载器(Extension ClassLoader)**

   负责加载`<JAVA_HOME>/lib/ext`目录下的类库。

3. **应用程序类加载器(Application ClassLoader)**

   负责加载`java -classpath`下的类库

一般情况下，类的加载都是由上述三种类加载器互相配合完成的。

所谓**双亲委派机制**，就是指当一个了类加载器接收到类的加载请求时，不会自己立马去加载这个类，而是委派给父类的加载器完成<font size="2">(此处的父子关系是通过组合实现的而非继承，即子类持有父类引用)</font>，所以每次类加载都会被`Bootstrap ClassLoader`接收到，之后在逐层反馈，在父类不能加载的时候尝试自己加载。

使用双亲委派机制的优点就是Java类随着类加载器一起有了一种优先级的层次关系，例如用户如果定义了一个Java.lang.String或者Object，最终都会通过`Bootstrap ClassLoader`加载到JDK中的内置类。

1. 避免重复加载，父加载器加载之后不需要子加载器再进行加载。
2. 安全性考虑，核心API只能由`Bootstrap ClassLoader`加载

​	

---

## 推荐阅读链接

[深入理解Java类加载器(ClassLoader)](https://blog.csdn.net/javazejian/article/details/73413292)							

























