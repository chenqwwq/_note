# MySQL 索引相关



## 索引的结构

索引就是用来加速查询速度的结构，索引的结构有B+树，B树或者 Hash索引。

> InnoDB 中以B+树为主，存在自适应 Hash索引，提供特殊的查询。



B+ 树就是平衡的搜索树，可以简单理解为是二叉搜索树（BST）或者二叉平衡树（AVL）的变种。

二叉搜索树**就是任意节点左右子树的高度差不超过1的树，**为了维持这种特性需要大量的旋转操作，并且随着深度的增加搜索的效率也会慢慢降低，在动辄千万亿万的数据的数据库中，二叉搜索树明显是不合适的。

M 阶的B+树，根节点的节点数为[2,M]，索引节点的节点数为[M/2,M]，**而且保证了数据的有序性质**，所以层次更低，查询速度更快也更平稳。

> 因为B+树数据有序性的特点，所以如果不使用单调递增的索引键，在插入和删除操作时候就会存在页分裂和页合并的问题，十分影响效率。



相对于B 树来说，B+ 树的所有数据都在子节点中，这样的**查询更加稳定**，所有的查询都需要树高度次的查询，并且所有的子节点**组成一个链表**，这样非常便于**实现范围查询**。

> 所有的数据都在子节点，而索引数据在非子节点，可以一次性加载尽量多的数据，或者直接将一个节点的数据封装为一个数据页，更有利于搜索。



Hash 索引应该是所有索引中速度最快的，插入和获取都可以达到理论的O(1)复杂度，但是 Hash索引 基本无法实现范围查询。

> 简单的例如 Redis，就可以理解为一个 Hash索引的优良实现。





## 索引的类型

### 聚集索引和稀疏索引

聚集索引直接定义了数据在表中物理的存储顺序，所以每张表最多只有一个聚集索引，在 InnoDB 中，聚集索引就是主键索引，所有的数据都保存在主键索引的叶子节点中。

InnoDB 中，主键索引决定了数据的物理存储顺序，应该更能理解主键的乱序插入带来的页分裂等等问题了。

> 如果没有明确定义表的主键，MySQL 也会自动生成一个唯一非空索引作为主键。

稀疏索引就是非聚集索引，和聚集索引相反的它的逻辑顺序和物理的存储顺序就是完全无关的。

InnoDB 的实现中，次级索引都是稀疏索引，保存的是主键。

> 所以 InnoDB 中存在回表操作，就是在一个索引树中无法完全确定数据是否可用时，先返回主键，查询完整的数据再来判断。
>
> 增加单索引中字段，索引下推，索引联合都可以起到减少回表的作用。

MyISAM 中的稀疏索引实现不同，MyISAM 中所有的索引树都是稀疏索引，包括主键在内，保存的都是数据的地址。

> MyISAM 和 InnoDB 的不同在这里就有体现：
>
> MyISAM 支持没有主键，理论上来说 MyISAM 的主键索引和次级索引没有任何区别。
>
> MyISAM 的索引中保存的都是数据地址，而 InnoDB 的次级索引保存的主键。





### 简单对比下 InnoDB 和 MyISAM

1. InnoDB 支持事务，而 MyISAM 不支持。

> 不支持事务也就表示 MyISAM 无法提供有效的 ACID 保证，这对于商业项目非常致命。

2. InnoDB 支持外键，而MyISAM 不支持。

> emmm... 其实无所谓，外键对上层业务也有产生约束，一般来说外键还是依靠上层业务来实现比较合适。

3. InnoDB 采用了聚集索引，每个表的主键索引就是聚集索引，而 MyISAM 只有非聚集索引，甚至可以没有主键。

> 如果说聚集索引定义了数据的物理存储的顺序，因为 MyISAM 没有聚集索引，所以也就没有明确的数据顺序，根据索引的不同会有不同的展现。
>
> 另外数据的无序，也就没有 InnoDB 的页分裂等问题。

4. InnoDB 支持行锁，甚至多粒度上锁，而 MyISAM 只有表锁。

> 在插入语句执行的时候，MyISAM 会锁住整张表，这个粗粒度的操作就会导致并发程度下降很多。

5. InnoDB 并没有保存记录数，而 MyISAM 保存了。

> emmm.  InnoDB 的 COUNT 基本上是要扫描的不管是二级索引树还是主键索引，而 MyISAM 的查找就是O(1)的时间复杂度。