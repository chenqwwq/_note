# 日志相关



MySQL 中存在多种日志，比如 binlog ，redo log 以及 undo log。



## bin log

 binlog 属于归档日志，在 MySQL 中属于 Server 层日志，任何在 MySQL 中的存储引擎都会记录该日志。

binlog  记录了所有的数据库变更操作，包括 UPDATE，INSERT，DELETE，也包括表结构的修改 ALTER TABLE等。

> binlog 不会记录 SELECT 语句，因为 SELECT 不会对表数据造成变更。
>
> UPDATE 即使没有更新任何数据也会被记录，因为 UPDATE 是 Server 层日志，此时并不知道语句的执行结果。

**binlog 在 MySQL 中最重要的作用就是用于做主从同步，binlog 会从主节点扩散到从节点执行，从库再执行，使两库数据保持最终一致性。**

再说两个 binlog 相关的主要配置：

> binlog_cache_size

该值表示在 MySQL 内存池中，binlog 缓冲区的大小，在缓冲区不足的时候 MySQL 会进行强制的**刷盘**，也就是将 binlog 落盘。

> sync_binlog 

binlog 的 fsync 刷盘策略。

为0时表示，系统自由决定何时刷盘，为1表示每次都需要执行刷redo log 盘，为N表示需要N次才会刷盘。

为0时性能最好，但是如果系统宕机，会丢失未落盘的内容。



**binlog 有statement，row 以及 mixed 三种格式。**

statement 完整的保存执行的语句，但是因为 now() 等即时函数的存在，复制的异常。

**row 记录的是表中数据 完整的变更，比如 now() 就会直接记录当前时间，数据较为准确，但是日志文件相对较大。**

mixed 基本上就是混合两种的情况。





## redo log

> ！！重要的点，redo log 是 InnoDB 的专有日志，其他的存储引擎，例如 MyISAM 都不具有。

redo log 是 InnoDB 中最重要的日志，是持久性实现的基石。

另外 redo log 就是 InnoDB 中 WAL 的实现。

> WAL 就是预写日志技术，在 InnoDB 中所有的修改都需要写日志，再做修改。
>
> WAL 一方面保证了数据的持久性，即使宕机导致数据并未落盘，但是日志此时都是完整的，可以借此恢复。
>
> 另外 InnoDB 的 redo log 实现的 WAL，进一步优化了写入的性能。

InnoDB 中的 redo log 有一个固定的大小，并且首尾相连组成一个环，换上有两个主要的指针: check_point 和 write_pos。

![img](https://chenqwwq-img.oss-cn-beijing.aliyuncs.com/img/16a7950217b3f0f4ed02db5db59562a7.png)

在 write_pos 和 check_point 之间的就是日志的可写范围，如果刷盘不及时导致 write_pos 追上了 check_point，就会开启强制的刷盘。

和 binlog 一样，redo log 的刷盘也有参数控制，**innodb_fluish_log_at_trx_commit**，该参数为1时，每次的 redo log 都会调用 fsync，真正落盘持久化保存。



## undo log

undo log 是 InnoDB MVCC 特性的重要组成部分，也可以说是基石。

undo log 在 5.6 之后记录在单独的表空间，并且使用回滚段作为组织的形式。

> 所以 undo log 并算不上 InnoDB WAL 机制的实现，因为 undo log 自身的持久化都要基于redo log。

undo log 会在事务提交的时候被删除，在正常查询时，如果当前的数据经过了几次修改，undo log 会变成类似链表的结构，查询需要沿着 undo log 逐步复原。

> 之前好像听过这个bug，就是一个长事务导致的巨长的 undo log，拖慢了整个表的查询速度。

undo log 简单理解就是相反操作，比如用户表中的插入，那么这里就记录删除。